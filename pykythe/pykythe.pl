% -*- mode: Prolog -*-

%% Post-processor for the simplified nodes with FQNs that are
%% generated by pykythe (see ast_cooked.Base.add_fqns).  The
%% post-processing is mainly:
%% - add Kythe anchor facts
%% - add facts/edges for attributes (e.g., "foo" in self.foo)
%% - resolve and process imports
%% - in future, things like function call references

%% See the README.md file for an over-all explanation of the system
%% design,particularly in how caches are used to improve performance.

%% This code heavily uses the EDCG notation (-->> and its extension
%% ==>>), which might be unfamiliar to you -- I suggest reading Peter
%% Van Roy's paper, referenced at the bottom of
%% https://github.com/kamahen/edcg
%%
%% There are 3 accumulators and one passed arg -- look for the
%% edcg:acc_info and edcg:pass_info facts for more information.  In
%% particular, `[ Fqn-Type-TypeSymtab ]:symrej` does a lookup into the
%% symbol table and inserts Fqn-[] (the "Any" type) if it's not there
%% (if it is there, Type is union-ed with whatever is alrady in the
%% symtab).

%% Names and naming conventions:
%%  'astn' is an AST (Abstract Syntax Tree) node.
%%  'fqn' is fully qualified name
%%  'ky' as prefix means 'kythe' (e.g. kyfact instead of kythe_fact)
%%  'symtab' is symbol table
%%  'symrej' is symbol table (symtab) + rejects (+ modules)

%% There are multiple passes over the AST:
%%
%% 0. [run_parse_cmd] Create a "cooked" AST (Python program specified
%%    by --parsecmd), generating a Prolog data structures of the AST
%%    (as a string).
%%
%% 1. [process_nodes] Read in the "cooked" AST (see ast_cooked.Base),
%%    transform the nodes into a simpler form, and produce (using
%%    accumulators):
%%    - Kythe facts (e.g., anchors) for all the variables and
%%      parameters in the code (but not the attributes);
%%    - references and assignments (in the assign/2 facts);
%%    - a few special items, such as anchors for import statements'
%%      dotted names.
%%    Each predicate also returns a "type" result that is used to
%%    populate the right-hand-side of assign/2 facts (for statements,
%%    a expr/1 term is returned for completeness.  For more details,
%%    see kynode//2.
%%
%% 2. [assign_exprs] Process the assign/2 and expr/1 facts, by
%%    interpreting the expressions and recording the results in a
%%    symtab (symbol table), then outputting Kythe facts for the
%%    attributes, calls, etc.  Note that expr([]) is a no-op.

%% Processing of "types" and "eval" ...

%% The input consists of a list of simplified items from the AST.
%% For example, this Python line (in class C2's __init__):
%%   self.x = 'C2_x'
%% is turned into something like the following (in portray-output format):
%%    'AssignExprStmt'{
%%        expr: 'StringNode'{astns: ['ASTN'(1160:1166, '\'C2_x\'')]},
%%        left: 'AtomDotNode'{
%%               atom: 'NameRefFqn'{
%%                         fqn: 'test_data.simple.C2.__init__.<local>.self',
%%                         name: 'ASTN'(1151:1155, 'self') },
%%               attr_name: 'ASTN'(1156:1157, 'x'),
%%               binds: bool('True') } }
%% When this is read in, it is simplified to something like this:
%%   assign([dot_op(var_ref('test_data.simple.C2.__init__.<local>.self')],
%%              astn(1156,1157, 'x'),
%%              '/kythe/edge/defines/binding'),
%%          [class_type('.home.peter.src.typeshed.stdlib.builtins.str', [])])
%%
%% To process this, we need to resolve the FQNs (in this case,
%% var_ref('test_data.simple.C2.__init__.<local>.self') by looking up
%% in the symtab, eventually resulting in the dot_op(...) expression
%% being reduced to var_ref('test_data.simple.C2.x')), which is then
%% looked up in the symtab.

%% The symtab dict maps an fqn to an ordset (possibly empty) of:
%%     class_type(Fqn,Bases)            % Bases is a list of union types
%%                                      % (All must be of type class_type)
%%     function_type(Fqn,Params,Return) % Return is a union type
%%     module_type(ModuleType)          % ModuleType is one of:
%%                                          module_alone(Module,Path)
%%                                          module_and_token(Module,Path,Token)
%%                                          module_star(Module,Path)}
%%                                      % all of which contain the FQN of the module
%%     import_ref_type(Name,Fqn,Type)   % wraps a *single* type that's imported; for
%%                                      % evaluation, use Type. Note that this
%%                                      % does not wrap a union type - for that,
%%                                      % use a list of import_ref_type(...)
% TODO: import_var_type?? for cases where a module defines a global variable
%       that's not a class or function.
%% In most cases, the FQN is known, but for some (e.g., from `import *`),
%% a "dynamic" lookup is done (see 'NameBindsGlobalUnknown', which
%% use an "expr" type of `var_binds_lookup`).
%%
%% There is always an entry ModuleFqn-module_type(module_alone(ModuleFqn,ModulePath)),
%% which (amongst other things) is usesd to prevent circular imports going into
%% an infinite loop.

%% Implementation detail: lookup is done using
%%        [ Fqn-Type-TypeSymtab ]:symrej
%% which calls symrej_accum/3 and uses the sym_rej/2 functor to record
%% the symtab, rejected symtab entries. It acts as both lookup and
%% insert - if the Fqn isn't in the symtab, it is added (with the
%% "Any" type or []); if it is in the symtab, Result is either unified
%% with the symtab value, or Result is unioned with the symtab value
%% (and the "rej" list is added to, if needed). TypeSymtab is unified
%% with what's in Symtab.
% TODO: using one form for both lookup and insertion was probably a
%       bad idea. Instead, the "/symrej" operator could be used to
%       get the accumulator and do an appropriate operation. Or the
%       "[...]:symrej" could have an option in it do specify whether
%       this is a lookup or insertion/update.
%%
%% A symtab lookup can occur either as in a right-hand (evaluation)
%% context or left-hand (assignment) context (see symrej_accum/3).
%%
%%  +---------+--------------+------------------------------+
%%  | Context | Entry exists |                              |
%%  |         | in symtab    | Action                       |
%%  +---------+--------------+------------------------------+
%%  | eval    | no           | add with type=[] ("Any")     |
%%  +---------+--------------+------------------------------+
%%  | eval    | yes          | use symtab type              |
%%  |         |              | add to "reject" list if new  |
%%  |         |              | type info                    |
%%  +---------+--------------+------------------------------+
%%  | assign  | no           | add with type of r.h.s.      |
%%  +---------+--------------+------------------------------+
%%  | assign  | yes          | unify with type of r.h.s     |
%%  |         |              | add to "reject" list if new  |
%%  |         |              | type info                    |
%%  +---------+--------------+------------------------------+
%%
%% New type info is determined by union-ing the two types and seeing
%% if the result is different from what's in the symtab -- if
%% different, the Fqn-Type is added to the "reject" list and the
%% symtab entry is updated with the additional type information.  If
%% there is new type information, it is because a previous "eval" node
%% was processed without all available information, so another pass
%% needs to be done over the "eval" nodes.  The next pass will also
%% add the new type information from the "reject" list to the symtab
%% before reprocessing all the "eval" nodes.
%%
%% See discussion below about reprocessing of "reject"ed items.

%% All types are unions (represented as an ordset); [] means that
%% there's no information and is effectively "Any". Many of the
%% predicates come in two versions: one that works with a type union
%% (ordset), and one that works on single "types", such as
%% class_type(...), function_type(...), etc. -- typically the predicate
%% that works with a type union iterates over the single items,
%% calling the predicate for single "types", and uses ord_union/3 to
%% combine the results.  (This use of ord_union/3 ensures that there's
%% no need to "flatten" the list and that the single types are kept in
%% a canonical order).  (There's a wrapper around this, to remove
%% unnecessary pieces -- see type_union/3 and friends.)

%% The list of assign(Left, Right) terms and expr(Right) terms is
%% repeatedly reprocessed until no changes occur (a count is kept of
%% eval passes, to prevent an infinite loop -- I suspect that an
%% infinite loop isn't possible; but it's a lot of work to actually
%% prove that). When a FQN is first encountered, it is put into the
%% symtab with its type (the type is [] if it can't be determined) --
%% when subsequently encountered, any inconsistency in type is added
%% to the "reject" list. After a pass is complete, the rejects' types
%% are union-ed with the corresponding symtab entries' types and if
%% there were changes, another pass is done. In this way, each
%% expression is repeatedly reprocessed until no more changes (in
%% practice, only one or two passes are needed).

%% Processing of modules ...
%%
%% Module imports are detected during the first pass, but are deferred
%% to the second pass (which builds up the symbol table). Modules are
%% also in the symtab -- they are used for processing the "." operator
%% (which can be used on either a class or a module [actually, on
%% anything]) and to stop recursive imports.

% TODO: try to remove the kyfact accumulator from the first pass
%       and generate all the Kythe information from the second pass

:- module(pykythe, [pykythe_main/0]).

:- encoding(utf8).
:- use_module(library(debug)). % explicit load to activate optimise_debug/0.

:- set_prolog_flag(warn_autoload, true). % TODO: this is an experimental flag
:- set_prolog_flag(autoload, false).
% :- use_module(library(apply_macros).  % TODO: for performance (also maplist_kyfact_symrej etc)
:- use_module(c3, [mro/2]).
:- use_module(library(aggregate), [aggregate_all/3, foreach/2]).
:- use_module(library(apply), [exclude/3, include/3, maplist/2, maplist/3, maplist/4, foldl/4, convlist/3, partition/4]).
:- use_module(library(assoc), [is_assoc/1, gen_assoc/3, max_assoc/3, min_assoc/3]).
:- use_module(library(debug), [assertion/1, debug/3]).
:- use_module(library(edcg)).   % requires: ?- pack_install(edcg).
:- use_module(library(error), [must_be/2, domain_error/2]).
:- use_module(library(gensym), [gensym/2]).
:- use_module(library(http/json), [atom_json_dict/3]).
:- use_module(library(lists), [append/2, append/3, list_to_set/2, last/2, member/2, nth0/3, reverse/2, select/3]).
:- use_module(library(optparse), [opt_arguments/3]).
:- use_module(library(ordsets), [list_to_ord_set/2, ord_empty/1, ord_union/2, ord_union/3, ord_add_element/3]).
:- use_module(library(pairs), [pairs_keys/2, pairs_values/2, pairs_keys_values/3]).
:- use_module(library(pcre), [re_replace/4]).
:- use_module(library(prolog_stack)).  % For catch_with_backtrace
:- use_module(library(utf8), [utf8_codes/3]).

:- use_module(module_path).
:- use_module(must_once, [must_once/1, must_once_msg/2, must_once_msg/3, fail/1,
                          must_once/3 as must_once_symrej]).
:- use_module(pykythe_utils).
:- use_module(pykythe_symtab).

% TODO: use_module(library(fastrw), [fast_read/2, fast_write/2, fast_term_serialized/2]).
%       for the generated facts (see also ../browser/src_browser.pl)

:- meta_predicate
       maplist_kyfact(4, +, +, -, +),
       maplist_kyfact(5, +, -, +, -, +),
       maplist_kyfact_(+, 4, +, -, +),
       maplist_kyfact_(+, 5, -, +, -, +),
       maplist_kyfact_expr(6, +, +, -, +, -, +),
       maplist_kyfact_expr(7, +, +, +, -, +, -, +),
       maplist_kyfact_expr_(+, 6, +, -, +, -, +),
       maplist_kyfact_expr_(+, 7, +, +, -, +, -, +),
       maplist_kyfact_symrej(6, +, +, -, +, -, +),
       maplist_kyfact_symrej(7, +, -, +, -, +, -, +),
       maplist_kyfact_symrej_(+, 6, +, -, +, -, +),
       maplist_kyfact_symrej_(+, 7, -, +, -, +, -, +),
       maplist_kyfact_symrej_union(7, +, -, +, -, +, -, +).

:- style_check(+singleton).
:- style_check(+var_branches).
:- style_check(+no_effect).
:- style_check(+discontiguous).
:- set_prolog_flag(warn_autoload, true).

:- multifile
    edcg:acc_info/5,
    edcg:pred_info/3,
    edcg:pass_info/1,
    user:portray/1,
    prolog:message//1.

% "kyfact" accumulator gets FQN anchor facts, in an ordinary list
% with each value being a dict to be output in JSON (and eventually
% to a protobuf). The list may contain duplicates, which are removed
% before output.

% TODO: Need test cases for this:
% Duplicates can arise if a variable is redefined in the Python
% source; our de-dup keeps the type information for the first such
% definition and outputs /kythe/edge/defines/binding for all
% instances.

% "kyfact" accumulator gets Kythe facts for outputting.
% TODO: check for duplicate edge facts that indicate a bug.
%       (although it's easier to just remove duplicates, which
%       is what we do)
edcg:acc_info(kyfact, T, Out, In, Out=[T|In]).

% "expr" accumulator gets expressions that need interpreting.
edcg:acc_info(expr, T, Out, In, Out=[T|In]).

% "symrej" accumulator is for symtab + rejected items that need reprocessing.
edcg:acc_info(symrej, FqnType, In, Out, symrej_accum(FqnType, In, Out)).

% "file_meta" passed arg contains meta-info about the current file.
edcg:pass_info(file_meta).

% This definition of edcg:pred/3 catches all situations where there's
% a goal in a -->> or ==>> predicate that hasn't been specified and
% isn't wrapped in {...}.
edcg:pred_info(Name, Arity, Accs) :-
    (   pred_info_(Name, Arity, Accs)
    *-> true
    ;   Name == (!), Arity == 0
    ->  true
    ;   Name == call
    ->  true
    ;   throw(error(no_pred_info(Name/Arity), _))
    ).

pred_info_(log_kyfact_msg, 5,                      [kyfact,file_meta]).
pred_info_(eval_single_type_error_msg, 4,          [kyfact,file_meta]).
pred_info_(maplist_kyfact, 2,                      [kyfact,file_meta]).
pred_info_(maplist_kyfact, 3,                      [kyfact,file_meta]).
pred_info_(maplist_kyfact_, 2,                     [kyfact,file_meta]).
pred_info_(maplist_kyfact_, 3,                     [kyfact,file_meta]).

pred_info_(kyanchor, 4,                            [kyfact,file_meta]).
pred_info_(kyanchor_binding, 4,                    [kyfact,file_meta]).
pred_info_(kyanchor_binding, 6,                    [kyfact,file_meta]).
pred_info_(kyanchor_kyedge_fqn, 5,                 [kyfact,file_meta]).
pred_info_(kyanchor_node, 2,                       [kyfact,file_meta]).
pred_info_(kyanchor_node, 3,                       [kyfact,file_meta]).
pred_info_(kyanchor_node_kyedge_fqn, 3,            [kyfact,file_meta]).
pred_info_(kyanchor_node_kyedge_fqn, 4,            [kyfact,file_meta]).
pred_info_(kyedge, 3,                              [kyfact,file_meta]).
pred_info_(kyedge_fqn, 3,                          [kyfact,file_meta]).
pred_info_(kyedge_fqn_fqn, 3,                      [kyfact,file_meta]).
pred_info_(kyfact, 3,                              [kyfact,file_meta]).
pred_info_(kyfact_attr, 3,                         [kyfact,file_meta]).
pred_info_(kyfact_color_text_as_single_fact, 1,    [kyfact,file_meta]).
pred_info_(kyfact_signature_node, 3,               [kyfact,file_meta]).
pred_info_(kyfacts, 2,                             [kyfact,file_meta]).
pred_info_(kyfacts_signature_node, 2,              [kyfact,file_meta]).
pred_info_(kyfile, 1,                              [kyfact,file_meta]).
pred_info_(add_kyfact_types, 2,                    [kyfact,file_meta]).
pred_info_(symtab_pykythe_types, 1,                [kyfact,file_meta]).

pred_info_(maplist_kyfact_expr, 2,                 [kyfact,expr,file_meta]).
pred_info_(maplist_kyfact_expr, 3,                 [kyfact,expr,file_meta]).
pred_info_(maplist_kyfact_expr_, 2,                [kyfact,expr,file_meta]).
pred_info_(maplist_kyfact_expr_, 3,                [kyfact,expr,file_meta]).

pred_info_(assign_normalized, 2,                   [kyfact,expr,file_meta]).
pred_info_(assign_normalized2, 2,                  [kyfact,expr,file_meta]).
pred_info_(expr_normalized, 1,                     [kyfact,expr,file_meta]).
pred_info_(import_from, 1,                         [kyfact,expr,file_meta]).
pred_info_(kyImportDottedAsNamesFqn, 2,            [kyfact,expr,file_meta]).
pred_info_(kyImportDottedAsNamesFqn_as, 4,         [kyfact,expr,file_meta]).
pred_info_(kyImportDottedAsNamesFqn_as_unknown, 4, [kyfact,expr,file_meta]).
pred_info_(kyImportDottedAsNamesFqn_from_dots, 4,  [kyfact,expr,file_meta]).
pred_info_(kyImportDottedAsNamesFqn_from_part, 3,  [kyfact,expr,file_meta]).
pred_info_(kyImportDottedAsNamesFqn_from_part2, 4, [kyfact,expr,file_meta]).
pred_info_(kyImport_path_pieces_to_module, 4,      [kyfact,expr,file_meta]).
pred_info_(kyImportDottedAsNamesFqn_top, 3,        [kyfact,expr,file_meta]).
pred_info_(kyImport_path_dots, 1,                  [kyfact,expr,file_meta]).
pred_info_(kyImportFromStmt, 5,                    [kyfact,expr,file_meta]).
pred_info_(kynode, 2,                              [kyfact,expr,file_meta]).
pred_info_(kynode, 3,                              [kyfact,expr,file_meta]).
pred_info_(kynode_add_items, 1,                    [kyfact,expr,file_meta]).
pred_info_(kynode_add_items2, 1,                   [kyfact,expr,file_meta]).
pred_info_(kynode_if_stmt, 2,                      [kyfact,expr,file_meta]).
pred_info_(kynode_impl, 2,                         [kyfact,expr,file_meta]).
pred_info_(maplist_kynode, 2,                      [kyfact,expr,file_meta]).
pred_info_(process_nodes_impl, 2,                  [kyfact,expr,file_meta]).

pred_info_(maplist_kyfact_symrej, 2,               [kyfact,symrej,file_meta]).
pred_info_(maplist_kyfact_symrej, 3,               [kyfact,symrej,file_meta]).
pred_info_(maplist_kyfact_symrej_, 2,              [kyfact,symrej,file_meta]).
pred_info_(maplist_kyfact_symrej_, 3,              [kyfact,symrej,file_meta]).
pred_info_(maplist_kyfact_symrej_union, 3,         [kyfact,symrej,file_meta]).

pred_info_(eval_assign_dot_op_binds_single2, 4,    [kyfact,symrej,file_meta]).
pred_info_(eval_assign_dot_op_binds_single, 4,     [kyfact,symrej,file_meta]).
pred_info_(eval_assign_dot_op_binds_unknown, 4,    [kyfact,symrej,file_meta]).
pred_info_(eval_assign_expr, 1,                    [kyfact,symrej,file_meta]).
pred_info_(eval_assign_import, 1,                  [kyfact,symrej,file_meta]).
pred_info_(eval_assign_single, 3,                  [kyfact,symrej,file_meta]).
pred_info_(eval_assign_subscr_op_binds_single, 2,  [kyfact,symrej,file_meta]).
pred_info_(eval_atom_call_single, 3,               [kyfact,symrej,file_meta]).
pred_info_(eval_atom_dot_single, 3,                [kyfact,symrej,file_meta]).
pred_info_(eval_atom_subscr_binds_single, 2,       [kyfact,symrej,file_meta]).
pred_info_(eval_atom_subscr_single, 2,             [kyfact,symrej,file_meta]).
pred_info_(eval_dot_op_unknown, 3,                 [kyfact,symrej,file_meta]).
pred_info_(eval_single_type, 2,                    [kyfact,symrej,file_meta]).
pred_info_(eval_single_type_import, 5,             [kyfact,symrej,file_meta]).
pred_info_(eval_union_type, 2,                     [kyfact,symrej,file_meta]).
pred_info_(log_possible_classes_from_attr, 4,      [kyfact,symrej,file_meta]).
pred_info_(maplist_eval_assign_expr, 1,            [kyfact,symrej,file_meta]).
pred_info_(maybe_resolve_mro_dot, 3,               [kyfact,symrej,file_meta]).
pred_info_(resolve_mro_dot, 4,                     [kyfact,symrej,file_meta]).
pred_info_(subscr_resolve_dot_binds, 3,            [kyfact,symrej,file_meta]).

pred_info_(possible_classes_from_attr, 2,          [symrej,file_meta]).
pred_info_(resolve_unknown_fqn, 4,                 [symrej,file_meta]).
pred_info_(symtab_if_file, 1,                      [symrej,file_meta]).

pred_info_(must_once_symrej, 1,                    [symrej]).
pred_info_(symtab_lookup, 2,                       [symrej]).
pred_info_(symtab_scope_pairs, 2,                  [symrej]).

pred_info_(diagnostic_source, 2,                   [file_meta]).
pred_info_(do_if_file, 1,                          [file_meta]).
pred_info_(log_if_file, 2,                         [file_meta]).
pred_info_(signature_node, 2,                      [file_meta]).
pred_info_(signature_source, 2,                    [file_meta]).

pred_info_(exprs, 1,                               [expr]).

% For debugging, load this file (using `swipl -l pykythe/pykythe.pl` or
% by using `[pykythe/pykythe].`) -- this does not run the initialization.
%       set_prolog_flag(autoload,true).  debug.
%       pykythe:pykythe_main2.
% or from a script:
%      echo "pykythe:pykythe_main" | swipl ...
% Note that for running in an emacs shell, you might want swipl --no-tty
% See https://groups.google.com/forum/#!topic/swi-prolog/WrC9x3vQBBY

:- initialization(pykythe_main, main).

%! main is det.
% The main predicate, run during initialization.
% See also library(main)'s definition of main
% This simply calls pykythe_main2, so that we can do:
%   :- use_module(library(test_cover), [show_coverage/1]).
%   pykythe_main :-
%       set_prolog_flag(autoload, true),
%       profile(pykythe:pykythe_main2).
% or:
%   :- use_module(library(statistics)).
%   pykythe_main :-
%       set_prolog_flag(autoload, true),
%       profile(pykythe:pykythe_main2).
%
% Profiling results appeared to show that over 87% of time was spent
% in reading in the JSON from the parser, writing out the results, or
% garbage collection. So, to improve performance, the low hanging
% fruit seemed to be:
%   - output the AST as a Prolog term.
%   - use another output format than JSON (e.g., protobufs)
% So, I changed the AST to be a Prolog term, but that only gave a 10%
% performance boost. :(
%
% After changing to Prolog term for AST, the low-hanging fruit
% appears to be:
%    write_kythe_facts/2  (15%)
%    write_batch_symtab/3 (11%) <== mostly in format/3 - would term_string/2 be better?
%    put_dict/4           (25%)
%      - garbage_collect             (13%)
%      from builtins_symtab_extend/4 (11%)
%      from symrej_accum/3           (18%)
%
% When processing from a cache file (batch), almost all the time
% is taken by:
%     update_symtab
%       put_dict/4         27%
%       garbage collection 67%

% TODO: remove following? Need to summarize performance.
% For this, the low-hanging fruit is changing symtab from dict to
% assoc or rbtree (probably rbtree). We also need a faster merge of
% symtab entries (neither library(assoc) nor library(rbtrees) has a
% "merge", although they both have a way of converting an ordered
% list to a tree, which can probably be modified to add to an
% existing tree.
%
% Old profiling results:
%   CONCLUSION: it's worth computing SHA-1 for source, to avoid
%               all the decoding.
%   CONCLUSION: cache is worthwhile (11.5s vs 2.3s for builtins and imports)
%               -- 2.0s when SHA1 used (disappointing optimization)
%   for processing builtins.pyi (2.3s user time) from all cache
%                       (15 files, 64K lines, 17MB, src: 186KB,
%                        which ends up with 2318 symtab entries):
%   (for builtins.kythe.json only, ~0.4s, so eliminating all the
%    recursive checking of imports would save ~2s)
%   Most expensive operations were:
%      maybe_read_symtab_from_cache/5 70%
%          base64_term/2                  42%
%            base64/2                         41%
%          json_read_dict_validate/3      28%
%            json_read_dict/2                 28%
%      update_symtab/3                30%
%          put_dict/4                     28%
%   After removing the base64 encoding/decoding for symtab, this became (1.7s):
%      update_symtab/3                56%
%          put_dict/4                     55%
%      maybe_read_symtab_from_cache/5          41%
%          json_read_dict/2               34%
%      $garbage_collect/1             29%      (mostly from put_dict/4)

% Predicates that are loaded below by load_files(opts.builtins_symtab):
:- dynamic
    builtins_module/1,
    builtins_pairs/1,
    builtins_symtab/1,
    builtins_symtab_modules/1,
    builtins_symtab_primitive/2,
    builtins_version/1.

:- det(object_fqn/1).
%! object_fqn(-ObjectFqn) is det.
% Unify with the FQN for object '${TYPESHED_FQN}.stdlib.builtins.object'.
% Only works after builtins symtab has been loaded (see pykythe_main2/0).
% TODO: 2020/05/18 - object_fqn([class_type(ObjectFqn, [])]).
object_fqn(ObjectFqn) =>
    builtins_symtab_primitive(object, [ObjectType]),
    single_type_fqn(ObjectType, ObjectFqn).

:- det(pykythe_main/0).
%! pykythe_main is det.
% By default, this is called as part of initialization. It sets up
% an error handler and some appropriate global limits, then calls
% pykythe_main2/0 to process the files according to the command line
% arguments.
pykythe_main =>
    % TODO: change ast_raw._EXPR_NODES to reduce the number of expr nodes
    % The stack limit depends on some cuts that are marked '% "cut" for memory usage'
    %     (especially the ones marked '*** THIS ONE IS IMPORTANT ***').
    set_prolog_flag(stack_limit, 1_610_612_736), % TODO: 1.5GB - default of 1GB might suffice

    % TODO: catch_with_backtrace/3 wrap might not be needed when the
    %       initialization/2 directive is enabled.
    catch_with_backtrace(pykythe_main2,
                         Error,
                         ( print_message(error, Error),
                           halt(1) )),
    log_if(true, 'End'),                         % TODO: delete
    halt(0).

:- det(pykythe_main2/0).
%! pykythe_main2 is det.
% Called by pykythen_main/0, which is called by initalization. Sets up
% error handlers and some global limits, then processes the files, as
% sepcified by the command line.
pykythe_main2 =>
    % the stack traces are controlled by 4 Prolog flags defined in library(prolog_stack):
    % :- create_prolog_flag(backtrace,            true, [type(boolean), keep(true)]).
    % :- create_prolog_flag(backtrace_depth,      20,   [type(integer), keep(true)]).
    % :- create_prolog_flag(backtrace_goal_depth, 3,    [type(integer), keep(true)]).
    % :- create_prolog_flag(backtrace_show_lines, true, [type(boolean), keep(true)]).
    set_prolog_flag(backtrace_goal_depth, 30), % see library(prolog_stack)
    % set_prolog_flag(gc, true),  % TODO: tune GC for performance
    % set_prolog_flag(agc_margin, 0),  % TODO: tune GC for performance
    % set_prolog_flag(trace_gc, true),  % TODO: delete
    on_signal(int, _, throw),  % TODO: delete?
    on_signal(term, _, throw),  % TODO: delete?
    % on_signal(int, _, interrupt),  % TODO: reinstate if don't need traceback
    % Play nice with emacs *compilation* buffer -- might not be needed
    % with latest version of SWI-Prolog that uses TERM to decide
    % whether colorization should be done:
    set_prolog_flag(color_term, false), % TODO: delete (move to ~/.swiplrc)

    pykythe_opts(SrcPaths, Opts),
    log_if(true, 'Start ~w', [SrcPaths]), % TODO: delete
    % BuiltinsSymtabFile is created by gen_builtins_symtab.pl
    unload_file(Opts.builtins_symtab),
    load_files([Opts.builtins_symtab], % TODO: should be a module that lists its exported predicates
               [silent(true),
                imports([builtins_module/1,
                         builtins_pairs/1,
                         builtins_symtab/1,
                         builtins_symtab_modules/1,
                         builtins_symtab_primitive/2,
                         builtins_version/1])]),
    % debug, % TODO: remove - this "debug" gives a better traceback, at
             %       the cost of significant slow-down and memory usage.
    maplist(process_src(Opts), SrcPaths),
    log_if(true, 'End ~w', [SrcPaths]).        % TODO: delete

:- det(process_src/2).
%! process_src(+Opts:list, +SrcPath:atom) is det.
% Process a single source file
process_src(Opts, SrcPath) =>
    log_if(true, 'Start ~w', [SrcPath]),
    path_to_module_fqn_or_unknown(SrcPath, SrcFqn),
    builtins_symtab(Symtab0),
    process_module_cached_or_from_src(Opts, 'from src ok', SrcPath, SrcFqn, Symtab0, _Symtab).

:- det(path_with_suffix/4).
%! path_with_suffix(+Opts:dict, +SrcPath:atom, +Suffix:atom, -Path:atom) is det.
% Create Path from SrcPath's base and Opts.Suffix.
path_with_suffix(Opts, SrcPath, Suffix, Path) =>
    src_base(SrcPath, SrcPathBase),
    atomic_list_concat([Opts.kytheout, SrcPathBase, Suffix], Path).

%! interrupt(+Signal)
% An interrupt handler, installed by on_signal/3.
interrupt(_Signal) :-
    halt(1).

:- det(pykythe_opts/2).
%! pykythe_opts(-SrcPaths:list(atom), -Opts:dict) is det.
% Process the command line, getting the source file and options.
% Adds "fake" options that contain the full file paths generated
% from the suffixes.
pykythe_opts(SrcPaths, Opts) =>
    validate_prolog_version,
    OptsSpec =
       [[opt(builtins_symtab), type(atom), default(''), longflags(['builtins_symtab']),
         help('File containing a builtins_symtab/1 fact')],
        [opt(builtins_path), type(atom), default(''), longflags(['builtins_path']),
         help('Module for builtins (corresponding file should also be in --pythonpath)')],
        [opt(entriescmd), type(atom), default('entriescmd-must-be-specified'), longflags([entriescmd]),
         help('Command for running conversion of .kythe.json to .kythe.entries')],
        [opt(kythe_corpus), type(atom), default(''), longflags(['kythe_corpus']),
         help('Value of "corpus" in Kythe facts')],
        [opt(kythe_root), type(atom), default(''), longflags(['kythe_root']),
         help('Value of "root" in Kythe facts')],
        [opt(kytheout), type(atom), default(''), longflags(['kytheout']),
         help('Directory for output of imported files (including "main" file)')],
        [opt(parsecmd), type(atom), default('parsecmd-must-be-specified'), longflags([parsecmd]),
         help('Command for running parser than generates fqn.kythe.json file')],
        [opt(python_version), type(integer), default(3), longflags(python_version),
         help('Python major version')],
                                % TODO: python_version should be a triple: see fakesys.FAKE_SYS
        [opt(pythonpath), type(atom), default(''), longflags(['pythonpath']),
         help('Similar to $PYTHONPATH for resolving imports (":"-separated paths)')],
        [opt(version), type(atom), default(''), longflags(['version']),
         help('Pykythe version, used to validate cache entries')],

        [opt(pykythebatch_suffix), type(atom), default(''), longflags(['pykythebatch_suffix']),
         help(['Suffix (extension) for creating cache batch files (see README).',
               'If omitted or "", batch cache isn\'t used.'])],
        [opt(kytheentries_suffix), type(atom), default('.kythe.entries'), longflags(['kytheentries_suffix']),
         help('Suffix (extension for Kythe protouf output files - should have leading "."')],
        [opt(kythejson_suffix), type(atom), default('.kythe.json'), longflags(['kythout_suffix']),
         help('Suffix (extension) for output files - should have leading ".".')],
        [opt(pykythesymtab_suffix), type(atom), default('.pykythe.symtab'), longflags(['pykythesymtab_suffix']),
         help('Suffix (extension) for cache symtab files - should have leading ".".')],
        [opt(pykythecolor_suffix), type(atom), default('.pykythe.color.json'), longflags(['pykythecolor_suffix']),
         help('Suffix (extension) for color files - should have leading ".".')]
       ],
    opt_arguments(OptsSpec, OptsList, PositionalArgs),
    dict_create(Opts0, opts, OptsList),
    split_atom(Opts0.pythonpath, ':', '', PythonpathList0),
    convlist(maybe_absolute_dir, PythonpathList0, PythonpathList),
    path_to_module_fqn_or_unknown(Opts0.builtins_path, BuiltinsModule),
    put_dict([pythonpath-PythonpathList,
              builtins_module-BuiltinsModule], Opts0, Opts),
    must_once_msg(PositionalArgs = [_|_], 'Missing positional arg (file to process)'),
    maplist(absolute_file_name_rel, PositionalArgs, SrcPaths).

:- det(process_module_cached_or_from_src/6).
%! process_module_cached_or_from_src(+Opts:list, +FromSrcOk:{'from src ok','cached only'}, +SrcPath:atom, +SrcFqn:atom, +Symtab0, -Symtab) is det.
%
% General algorithm for processing modules.
%
% Modules are handled by the symrej accumulator and are therefore not
% processed when they are first imported but instead are processed as
% part of "pass 2" (assign_exprs/6)
%
% A module might be "from_src" (hasn't been previously processed) or
% "cached". If it's cached, the cached value is used only if:
%    - the source file is the same (using hash_hex/2)
%    - the cache file was processed with the same version of pykythe
%    - (recursively) all of the modules that it uses are cached
% Checking this can be slow, so an optimization is to use the "batch
% ID" to avoid the recursive check for all modules being cached (the
% "batch" cache file is also in a different format, for performance).
%
% If the value of FromSrcOk is 'cached only', the predicate will fail
% if any attempt is made to use a from_src version (that is, if the
% above conditions for using a cache file fail); and this is
% propagated up by failing all the way to the top, at which point,
% processing is done with the 'from src ok' value.
%
% When a module is processed, it updates the symtab.
% When a module is output (to the cache), all its symtab entries are output,
% including (recursively) imported symbols.
%
% One more detail ... it's possible that there are circular recursive
% imports, so a module's entry in the symtab is used to prevent an
% infinite recursion.
process_module_cached_or_from_src(Opts, FromSrcOk, SrcPath, SrcFqn, Symtab0, Symtab) :-
    assertion(var(Symtab)),  % TODO: remove
    (   symtab_lookup(SrcFqn, Symtab0, _ModuleValue)
    ->  % Module in symtab (possibly recursive import): skip it.
        Symtab = Symtab0,
        % TODO: use general debug flag for following:
        log_if(trace_file(SrcPath), 'Skipping (already processed/processing) ~q: ~q', [SrcPath, SrcFqn])
    ;   maybe_process_module_cached(Opts, FromSrcOk, SrcPath, Symtab0, Symtab)
    ->  true
    ;   process_module_from_src(Opts, FromSrcOk, SrcFqn, Symtab0, Symtab)
    ).

:- det(modules_in_symtab/2).
%! modules_in_symtab(+Symtab, -Modules:list) is det.
% Create a set of all modules that appear as the type for symtab entries.
modules_in_symtab(Symtab, Modules) =>
    symtab_values(Symtab, SymtabValues),
    append(SymtabValues, AllTypes),
    % TODO: Need the equivalent of convlist for rbtrees
    include(is_module, AllTypes, Modules0),
    list_to_union_type(Modules0, Modules).

%! is_module(+SingleType) is semidet.
% Used by modules_in_symtab/2.
is_module(module_type(_)).
is_module(import_ref_type(_Name, _Fqn, Type)) :-
    is_module(Type).

:- det(modules_in_exprs/2).
%! modules_in_exprs(+Exprs, -Modules:list) is det.
% Create a set of all modules that appear in an "import" statement.
modules_in_exprs(Exprs, Modules) =>
    convlist(maybe_assign_import, Exprs, Modules0),
    list_to_union_type(Modules0, Modules).

%! maybe_assign_import(+Expr, -SingleType) is semidet.
% Used by modules_in_exprs/2.
maybe_assign_import(Term, module_type(Module)) :-
    is_dict(Term, assign_import),  % Term = assign_import{...}
    Term.module_and_maybe_token = Module.

%! maybe_process_module_cached(+Opts:list, +FromSrcOk:{'from src ok','cached only'}, +SrcPath:atom, +Symtab0, -Symtab) is semidet.
% If possible use the cache file to have the same effect as running
%   process_module_from_src/5.
% The logic is:
%   conditionally open Opts.kythejson_PATH (which should be an absolute file name)
%   if it succeeeds, run process_module_cached_impl/7
%     this can fail if the cached file isn't valid (e.g., older than the source)
%   [ensure that any open file is closed]
maybe_process_module_cached(Opts, FromSrcOk, SrcPath, Symtab0, Symtab) =>
    assertion(var(Symtab)),  % TODO: remove
    path_with_suffix(Opts, SrcPath, Opts.pykythesymtab_suffix, PykytheSymtabPath),
    setup_call_cleanup(
        maybe_open_read(PykytheSymtabPath, PykytheSymtabInputStream),
        maybe_process_module_cached_impl(Opts, FromSrcOk, PykytheSymtabInputStream, PykytheSymtabPath, SrcPath, Symtab0, Symtab),
        close(PykytheSymtabInputStream)),
    log_if(trace_file(SrcPath), 'Reused ~q for ~q', [PykytheSymtabPath, SrcPath]). % msg is output by process_module_cached_impl

%! maybe_process_module_cached_impl(+Opts:list, +FromSrcOk:{'from src ok','cached only'}, +PykytheSymtabInputStream, +SrcPath:atom, +Symtab0, -Symtab) is semidet.
% See README.md's section on caching for an explanation.
maybe_process_module_cached_impl(Opts, FromSrcOk, PykytheSymtabInputStream, PykytheSymtabPath, SrcPath, Symtab0, Symtab)  =>
    assertion(var(Symtab)),  % TODO: remove
    (   maybe_process_module_cached_batch(Opts, SrcPath, Symtab0, Symtab)
    ->  path_with_suffix(Opts, SrcPath, Opts.pykythebatch_suffix, PykytheBatchPath),
        log_if(true, 'Reused/batch(~w) ~q for ~q', [FromSrcOk, PykytheBatchPath, SrcPath])
    ;   % The following validation depends on what kyfile//1 generates.
        maybe_read_symtab_from_cache(
            Opts.version, PykytheSymtabInputStream, SrcPath, Symtab0, Symtab1,
            log_if(true, 'Cannot reuse cache (different version) ~q for ~q', [PykytheSymtabPath, SrcPath]),
            log_if(true, 'Cannot reuse cache (different source) ~q for ~q', [PykytheSymtabPath, SrcPath])),
        % recursively process modules, failing if any is "from_src"
        % (not cached). This will cause failure of
        % maybe_process_module_cached_impl/7, which will result in calling
        % process_module_from_src/5 for this module.  Any imported
        % modules that were processed will get re-processed (but use
        % the cached result).
        % TODO: modules_in_symtab not needed because foldl_process_module_cached_or_from_src/5
        %       skips non-modules.
        modules_in_symtab(Symtab1, ModulesInSymtab1),
        foldl_process_module_cached_or_from_src(Opts, 'cached only', ModulesInSymtab1, Symtab1, Symtab),
        path_with_suffix(Opts, SrcPath, Opts.kythejson_suffix, KytheJsonPath),
        log_if(true, 'Reused/cache(~w) ~q for ~q', [FromSrcOk, KytheJsonPath, SrcPath])
    ).

%! maybe_process_module_cached_batch(+Opts:list, +SrcPath:atom, +Symtab0: dict, -Symtab:dict) is semidet.
maybe_process_module_cached_batch(Opts, SrcPath, Symtab0, Symtab) =>
    Opts.pykythebatch_suffix \= '',
    path_with_suffix(Opts, SrcPath, Opts.pykythebatch_suffix, PykytheBatchPath),
    maybe_open_read(PykytheBatchPath, KytheStreamBatch),
    maybe_read_symtab_from_cache(
        Opts.version, KytheStreamBatch, SrcPath, Symtab0, Symtab,
        log_if(true, 'Cannot reuse batch cache (different version) ~q for ~q', [PykytheBatchPath, SrcPath]),
        log_if(true, 'Cannot reuse cache (different source) ~q for ~q', [PykytheBatchPath, SrcPath])).

:- det(foldl_process_module_cached_or_from_src/5).
%! foldl_process_module_cached_or_from_src(+Opts:list, +FromSrcOk:{'from src ok','cached only'}, +Modules:list, +Symtab0:dict, -Symtab:dict) is det.
foldl_process_module_cached_or_from_src(_Opts, _FromSrcOk, [], Symtab0, Symtab) =>
    assertion(var(Symtab)),  % TODO: remove
    Symtab = Symtab0.
foldl_process_module_cached_or_from_src(Opts, FromSrcOk, [M|Modules], Symtab0, Symtab) =>
    assertion(var(Symtab)),  % TODO: remove
    % TODO: handle module_star, merging its names into the symtab
    (   M = module_type(Module),
        path_part(Module, SrcPath), % TODO: fix failure for "import *"
        module_part(Module, SrcFqn)
    ->  % TODO: don't do this if module_and_token and module != module_path
        % or something like that
        % (although it'll just fail because the file doesn't exist)
        process_module_cached_or_from_src(Opts, FromSrcOk, SrcPath, SrcFqn, Symtab0, Symtab1)
    ;   Symtab1 = Symtab0
    ),
    foldl_process_module_cached_or_from_src(Opts, FromSrcOk, Modules, Symtab1, Symtab).

:- det(process_module_from_src/5).
%! process_module_from_src(+Opts:list, +FromSrcOk, +SrcFqn:atom, +Symtab0, -Symtab) is det.
% Read in a single file (JSON output from running --parsecmd, which
% encodes the AST nodes with FQNs), output Kythe JSON to current
% output stream. SrcPath must be in absolute form (leading '/').
% Fails if FromSrcOk isn't 'from src ok', otherwise succeeds.
process_module_from_src(Opts, 'from src ok', SrcFqn, Symtab0, Symtab) =>
    (   module_fqn_path(SrcFqn, SrcPath) % fails if file doesn't exist
    ->  process_module_from_src_impl(Opts, SrcPath, SrcFqn, Symtab0, Symtab)
    ;   Symtab = Symtab0,
        log_if(true,
               'Invalid/nonexistant module ~q', [SrcFqn])
        % TODO: output a dummy item, so that we don't unnecessarily
        %       reprocess (when looking for cache) things that depend
        %       on this module
    ).

:- det(process_module_from_src_impl/5).
%! process_module_from_src_impl(+Opts:list, +SrcPath:atom, +SrcFqn:atom, +Symtab0, -Symtab) is det.
process_module_from_src_impl(Opts, SrcPath, SrcFqn, Symtab0, Symtab) =>
    assertion(var(Symtab)),  % TODO: remove
    stats(Stats0),
    path_with_suffix(Opts, SrcPath, Opts.kythejson_suffix, KytheJsonPath),
    log_if(true,
           'Processing from source ~q (output: ~q) for ~q ~w', [SrcPath, KytheJsonPath, SrcFqn, Stats0]),
    parse_and_get_meta(Opts, SrcPath, SrcFqn, Meta, Nodes, ColorTexts),
    process_nodes(Nodes, src{src_fqn: Meta.src_fqn,
                             src_path: Meta.path,
                             color_text:ColorTexts},
                  KytheFactsFromNodes0, Exprs, Meta),
    log_kythe_fact_msgs(KytheFactsFromNodes0, KytheFactsFromNodes),
    modules_in_exprs(Exprs, ModulesInExprs),
    log_if(trace_file(SrcPath),
           'MODULES_IN_EXPRS: ~q', [[ModulesInExprs, src=SrcPath, SrcFqn]]),
    extend_symtab_with_builtins(Symtab0, Meta, Symtab1),
    do_if(trace_file(Meta.path), dump_term('PASS1-EXPR_MODULES', ModulesInExprs)),
    do_if(trace_file(Meta.path), dump_term('PASS1-EXPR', Exprs)),
    % Note that the following allows any imported module to be from_src
    % (FromSrcOk to process_module_cached_or_from_src is 'from src ok').
    % TODO: for ModulesInExprs that are module_star, need
    %       to update symtab with top-level items (starts
    %       with module. and doesn't have '.' inside).
    stats(Stats1),
    log_if(true, 'Pass 1: process nodes for ~q ~w', [Meta.path, Stats1]),
    foldl_process_module_cached_or_from_src(Opts, 'from src ok', ModulesInExprs, Symtab1, Symtab1WithImports),
    stats(Stats2),
    log_if(true, 'Pass 2: process exprs for ~q ~w', [Meta.path, Stats2]),
    assign_exprs(Opts, Exprs, Meta, Symtab1WithImports, Symtab, KytheFactsFromExprs0),
    log_kythe_fact_msgs(KytheFactsFromExprs0, KytheFactsFromExprs1),
    include(is_nonredundant_pytype_fact(Symtab), KytheFactsFromExprs1, KytheFactsFromExprs),
    stats(Stats3a),
    log_if(true, 'Pass 3a: output for ~q ~w', [Meta.path, Stats3a]),
    output_kythe(Opts, Meta, SrcPath, SrcFqn, Symtab, KytheFactsFromExprs, KytheFactsFromNodes),
    stats(Stats3b),
    log_if(true, 'Pass 3b: output for ~q ~w', [Meta.path, Stats3b]).

:- det(output_kythe/7).
%! output_kythe(+Opts:list, +Meta:dict, +SrcPath:atom, +SrcFqn:atom, +Symtab, +KytheFactsFromExprs:list, +KytheFactsFromNodes:list) is det.
output_kythe(Opts, Meta, SrcPath, SrcFqn, Symtab, KytheFactsFromExprs, KytheFactsFromNodes) =>
    assertion(validate_symtab(Symtab)),
    % Output /pykythe/type facts, for debugging.
    symtab_pykythe_types(Symtab, SymtabPykytheTypes, [], Meta), % phrase(symtab_pykythe_types(Symtab), SymtabPYkytheTypes, Meta)
    append([KytheFactsFromNodes, KytheFactsFromExprs, SymtabPykytheTypes], KytheFactsUncleaned),
    clean_kythe_facts(KytheFactsUncleaned, KytheFactsCleaned),
    % TODO: don't preserve order (for debugging) - use sort/2 to dedup:
    list_to_set(KytheFactsCleaned, KytheFacts),
    path_with_suffix(Opts, SrcPath, Opts.kythejson_suffix, KytheJsonPath),
    path_with_suffix(Opts, SrcPath, Opts.pykythesymtab_suffix, PykytheSymtabPath),
    path_with_suffix(Opts, SrcPath, Opts.pykythebatch_suffix, PykytheBatchPath),
    path_with_suffix(Opts, SrcPath, Opts.pykythecolor_suffix, PykytheColorPath),
    partition([Fact]>>get_dict(fact_name, Fact, '/pykythe/color_all'),
              KytheFacts, ColorFacts, KytheFacts2),
    log_if(true, 'Writing Kythe facts for ~q', [Meta.path]),
    write_atomic_stream(write_kythe_facts(KytheFacts2), KytheJsonPath, [encoding(utf8)]),
    log_if(true, '   Done writing ~q', [KytheJsonPath]),
    write_atomic_stream(write_kythe_facts(ColorFacts), PykytheColorPath, [encoding(utf8)]),
    log_if(true, '   Done writing ~q', [PykytheColorPath]),
    write_atomic_stream(write_symtab(Symtab, Opts.version, Meta.sha1), PykytheSymtabPath, [encoding(octet),type(binary)]),
    log_if(true, '   Done writing ~q', [PykytheSymtabPath]),
    (   PykytheSymtabPath = PykytheBatchPath
    ->  log_if(true, 'Not writing to kythebatch: ~w', KytheJsonPath)
    ;   % write_atomic_stream(write_symtab(Symtab, Opts.version, Meta.sha1), PykytheBatchPath, [encoding(octet),type(binary)])
        % Assume that if a race condition occurs while linking, the
        % other process would have generated the same file contents.
        % TODO: should re-process this file in case the race condition
        %       resulted in deleting the output file.
        catch(safe_hard_link_file_dup_ok(PykytheSymtabPath, PykytheBatchPath),
              error(existence_error(file, _), _), % context(_, 'No such file or directory')
              log_if(true, 'Failed to hard-link (file does not exist) ~q to ~q', [PykytheSymtabPath, PykytheBatchPath]))
    ),
    path_with_suffix(Opts, SrcPath, Opts.kytheentries_suffix, KytheEntriesPath),
    write_atomic_file(write_to_protobuf(Opts.entriescmd, SrcPath, KytheJsonPath), KytheEntriesPath, [encoding(utf8)]),
    log_if(true, '   Done writing ~q', [KytheEntriesPath]),
    log_if(true, 'Finished output ~q (~q) to ~q (~q)', [SrcPath, SrcFqn, KytheEntriesPath, KytheJsonPath]).

:- det(transform_kythe_fact/2).
%! transform_kythe_fact(+Fact0, -Fact1) is det.
% TODO: Note that this also changes fact_value to base64 and has special
%       cases for symtab, text, colors
transform_kythe_fact(json{source:Source0, fact_name:FactName, fact_value:FactValue}, Fact1) =>
    Fact1 = json{source:Source1, fact_name:FactName, fact_value:FactValueBase64},
    % text is alread in base64 (from Meta.contents_base64)
    (   FactName == '/kythe/text'
    ->  FactValueBase64 = FactValue
    ;   FactName == '/pykythe/color_all'
    ->  FactValueBase64 = FactValue
    ;   base64_utf8(FactValue, FactValueBase64)
    ),
    transform_kythe_vname(Source0, Source1).
% TODO: The following clause is a hack; the correct solution is to
%       modify pykythe_utils:absolute_file_name_rel to give the path
%       in the desired form, but there may be some subtle knock-on
%       effects (e.g., some code that depends on the derived module
%       FQN starting with ".", so that split_atom(Fqn, '.', '',
%       [''|_]) is assumed.
transform_kythe_fact(json{source:Source0, fact_name:'/', edge_kind:EdgeKind, target:Target0}, Fact1) =>
    Fact1 =          json{source:Source1, fact_name:'/', edge_kind:EdgeKind, target:Target1},
    transform_kythe_vname(Source0, Source1),
    transform_kythe_vname(Target0, Target1).

:- det(transform_kythe_vname/2).
transform_kythe_vname(json{corpus:Corpus, root:Root}, Fact1) =>
    Fact1 =           json{corpus:Corpus, root:Root}.
transform_kythe_vname(json{corpus:Corpus, root:Root, path:Path0}, Fact1) =>
    Fact1 =           json{corpus:Corpus, root:Root, path:Path1},
    transform_kythe_path(Path0, Path1).
transform_kythe_vname(json{corpus:Corpus, root: Root, path:Path0, language:Language}, Fact1) =>
    Fact1 =           json{corpus:Corpus, root: Root, path:Path1, language:Language},
    transform_kythe_path(Path0, Path1).
transform_kythe_vname(json{corpus:Corpus, root:Root, language:Language, signature:Signature}, Fact1) =>
    Fact1 =           json{corpus:Corpus, root:Root, language:Language, signature:Signature}.
transform_kythe_vname(json{corpus:Corpus, root:Root, language:Language, signature:Signature, path:Path0}, Fact1) =>
    Fact1 =           json{corpus:Corpus, root:Root, language:Language, signature:Signature, path:Path1},
    transform_kythe_path(Path0, Path1).

:- det(transform_kythe_path/2).
transform_kythe_path(AbsPath, RelPath) =>
    % Strip off the leading '/' - equivalent to atom_concat('/', RelPath, AbsPath)
    % TODO: Issue #24
    sub_atom(AbsPath, 0, 1, _, '/'),   % First char is '/'
    sub_atom(AbsPath, 1, _, 0, RelPath). % Strip first char.

:- det(parse_and_get_meta/6).
%! parse_and_get_meta(+Opts:list, +SrcPath:atom, +SrcFqn:atom, -Meta:dict, -Nodes, -ColorTexts:list) is det.
parse_and_get_meta(Opts, SrcPath, SrcFqn, Meta, Nodes, ColorTexts) =>
    builtins_version(BuiltinsVersion),
    must_once_msg(BuiltinsVersion == Opts.version,
                  'builtins_version(~q) should be ~q', [BuiltinsVersion, Opts.version]),
    get_time(T0),
    run_parse_cmd(Opts, SrcPath, SrcFqn, ParsedPath),
    get_time(T1),
    ParseTime is T1 - T0,
    % TODO: put parser run time into Meta returned from Opts.parsecmd
    log_if(true, 'Python parser: finished parsing/fqn (~2f sec) into ~q', [ParseTime, ParsedPath]),
    read_nodes(ParsedPath, Nodes, Meta, ColorTexts),
    log_if(true, 'Processed AST nodes from Python parser'),
    % Fill in dict items that were left uninstantiated in simplify_meta/2 (read_nodes/3):
    Meta.pythonpath = Opts.pythonpath,
    Meta.builtins_module = Opts.builtins_module,
    Meta.opts = Opts,
    Meta.version = Opts.version,
    assertion(SrcPath == Meta.path),
    Meta.src_fqn = SrcFqn.

:- det(extend_symtab_with_builtins/3).
%! extend_symtab_with_builtins(+Symtab0, +Meta:dict, -Symtab) is det.
extend_symtab_with_builtins(Symtab0, Meta, Symtab) =>
    builtins_pairs(BuiltinsPairs),
    builtins_symtab_extend(BuiltinsPairs, Meta.src_fqn, Meta.builtins_module, Symtab0, Symtab0a),
    symtab_insert(Meta.src_fqn, Symtab0a, [module_type(module_alone(Meta.src_fqn,Meta.path))], Symtab).

:- det(log_kythe_fact_msgs/2).
%! log_kythe_fact_msgs(-KytheFacts:list, +KytheFactsOut:list) is det.
% Process the KytheFacts list, outputting every msg{txt:Msg,astn:Astn} to the log;
% KytheFactsOut is all the non-log KytheFacts.
% The msg{...} items are generated by log_kyfact_msg//5.
% TODO: preserve the messages in the Kythe facts: https://kythe.io/docs/schema/#diagnostic
%       Needs an anchor with each fact.
log_kythe_fact_msgs([], KytheFactsOut) => KytheFactsOut = [].
log_kythe_fact_msgs([msg{message:MessageMsg,details:DetailsMsg,astn:Astn}|KytheFacts], KytheFactsOut) =>
    log_if(true, 'MESSAGE ~w: ~w ... ~w', [Astn, MessageMsg, DetailsMsg]),
    log_kythe_fact_msgs(KytheFacts, KytheFactsOut).
log_kythe_fact_msgs([Fact|KytheFacts], KytheFactsOut) =>
    KytheFactsOut = [Fact|KytheFactsOut2],
    log_kythe_fact_msgs(KytheFacts, KytheFactsOut2).

%! is_nonredundant_pytype_fact(+Symtab, +Fact) is semidet.
% Succeeds if this is either a non-/pykythe/type fact or if it's a
% /pykythe/type fact that isn't already in the symtab (with a warning
% logged if the symtab type isn't []).
is_nonredundant_pytype_fact(Symtab, Fact) :-
    (   Fact.fact_name == '/pykythe/type'
    ->  (   symtab_lookup(Fact.source.signature, Symtab, SymtabType)
        ->  term_string(FactType, Fact.fact_value),
            log_if((SymtabType \= FactType, FactType \= []),
                   'WARNING: ~q: Inconsistent symtab=~q, expr(ignored)=~q',
                   [Fact.source.signature, SymtabType, FactType]),
            fail
        ;   true
        )
    ;   true
    ).

:- det(builtins_symtab_extend/5).
%! builtins_symtab_extend(+FqnType:list(pair), +SrcFqn:atom, BuiltinsFqn, Symtab0:dict, +Symtab:dict) is det.
% Add the builtins to the symtab with the current SrcFqn.
builtins_symtab_extend([], _SrcFqn, _BuiltinsFqn, Symtab0, Symtab) => Symtab = Symtab0.
builtins_symtab_extend([Name-Type|FqnTypes], SrcFqn, BuiltinsFqn, Symtab0, Symtab) =>
    join_fqn([SrcFqn, Name], NameExt),
    join_fqn([BuiltinsFqn, Name], BuiltinsName),
    maplist(wrap_import_ref(Name,BuiltinsName), Type, WrappedType0),
    normalize_type(WrappedType0, WrappedType),
    symtab_insert(NameExt, Symtab0, WrappedType, Symtab1),
    builtins_symtab_extend(FqnTypes, SrcFqn, BuiltinsFqn, Symtab1, Symtab).

:- det(wrap_import_ref/4).
%! wrap_import_ref(+Name:atom, +Fqn:atom, +Type, -WrappedType) is det.
wrap_import_ref(Name, Fqn, Type, WrappedType) =>
    WrappedType = import_ref_type(Name,Fqn,Type).

:- det(single_type_fqn/2).
%! single_type_fqn(+Type, -Fqn:atom) is det.
% See also eval_atom_call_single//3, class_no_base/2, normalize_type2/2.
single_type_fqn(class_type(Fqn,_), Fqn2) => Fqn2 = Fqn.
single_type_fqn(module_type(Module), Fqn) =>
    full_module_part(Module, Fqn).
single_type_fqn(function_type(Fqn,_,_), Fqn2) => Fqn2 = Fqn.
single_type_fqn(import_ref_type(_,Fqn,_Type), Fqn2) => Fqn2 = Fqn.

:- det(class_no_base/2).
% See also single_type_fqn/2, eval_atom_call_single//3, normalize_type2/2.
class_no_base(class_type(Class,_), Class2) => Class2 = Class.
class_no_base(module_type(M0), M) =>
    full_module_part(M0, M).
class_no_base(import_ref_type(_Name, _Fqn, Type), TypeNoBase) =>
    class_no_base(Type, TypeNoBase).
class_no_base(X, X2) => X2 = X.

:- det(clean_kythe_facts/2).
%! clean_kythe_facts(-KytheFacts0:list, +KytheFacts:list) is det.
% Clean the Kythe facts so that they're acceptable to Kythe verifier
% and other downstream processing (e.g., remove inconsistent "kind"
% info).
% TODO: See https://github.com/kythe/kythe/issues/2381
clean_kythe_facts(KytheFacts0, KytheFacts) =>
    kythe_kinds(KytheFacts0, kinds{}, KytheFacts2, Kinds),
    dict_pairs(Kinds, kinds, KindsPairs),
    maplist(clean_kind, KindsPairs, Kinds2),
    % Kinds2 must come *after* KytheFacts - maybe_read_symtab_from_cache/5.
    append(KytheFacts2, Kinds2, KytheFacts).

:- det(kythe_kinds/4).
%! kythe_kinds(+Facts:list, +KindsIn:dict, -FactsOut, -KindsOut:dict) is det.
% Selects '/kythe/node/kind' facts and puts them into KindsOut (except
% for some "special" facts: anchor, package, file).  The `Kindsout`
% dict is keyed by the `Source` values of the 'kind' facts and
% contains a set of all the fact_values.
kythe_kinds([], Kinds, FactsOut, Kinds2) =>
    FactsOut = [],
    Kinds2 = Kinds.
kythe_kinds([json{fact_name:'/kythe/node/kind', fact_value:KindValue, source:Source}|Facts],
            KindsIn, FactsOut, KindsOut),
        KindValue \= 'anchor',  % should never have another kind
        KindValue \= 'package', % should never have another kind
        KindValue \= 'file'     % This is special (see maybe_read_symtab_from_cache/5)
  =>
    term_to_canonical_atom(Source, SourceAtom),
    get_dict_default(SourceAtom, KindsIn, [], KindSeen),
    type_add_element(KindSeen, KindValue, KindSeen2),
    put_dict(SourceAtom, KindsIn, KindSeen2, Kinds2),
    kythe_kinds(Facts, Kinds2, FactsOut, KindsOut).
kythe_kinds([Fact|Facts], Kinds, FactsOut, KindsOut) =>
    FactsOut = [Fact|FactsOut2],
    kythe_kinds(Facts, Kinds, FactsOut2, KindsOut).

:- det(clean_kind/2).
%! clean_kind(+SourceAtom_Kinds:pair, -Fact:dict) is det.
% Clean a single item, creating its JSON representation.
clean_kind(SourceAtom-Kinds, Cleaned) =>
    Cleaned = json{source:Source, fact_name:'/kythe/node/kind', fact_value:Kind},
    % See kyfact//3.
    term_to_atom(Source, SourceAtom),
    (   Kinds = [Kind]
    ->  true
    ;   maplist(precedence_and_kind, Kinds, PKs),
        keysort(PKs, [_-Kind|_]),
        log_if(true, 'INFO: Cleaned kind: ~q->~q for ~q', [Kinds, Kind, Source])
    ).

:- det(precedence_and_kind/2).
%! precedence_and_kind(+Kind, -PrecedenceKind:pair) is det.
% Map each kind to a pair with it precedence (for keysort)
precedence_and_kind(Kind, PrecedenceKind) =>
    PrecedenceKind = Precedence-Kind,
    kind_precedence(Kind, Precedence).

:- det(kind_precedence/2).
%! kind_prededence(+Kind, -Precedence) is det.
% The precedence for each 'kind' that we output.  This is used for
% "disambiguating" when there are multiple 'kind's for a node, with
% the lowest (most negative) precedence being chosen).  See also
% https://github.com/kythe/kythe/issues/2381
kind_precedence(file,     Precedence) => Precedence = -100.
kind_precedence(package,  Precedence) => Precedence =  -99.
kind_precedence(anchor,   Precedence) => Precedence =  -98.
kind_precedence(variable, Precedence) => Precedence =  -80.
kind_precedence(record,   Precedence) => Precedence =  -50.
kind_precedence(function, Precedence) => Precedence =  -49.

:- det(write_kythe_facts/2).
%! write_kythe_facts(+KytheFacts, +KytheOutStream) is det.
write_kythe_facts(KytheFacts, KytheOutStream) =>
    % write(KytheOutStream, "%% === Kythe ==="), nl(KytheOutStream),
    maplist(transform_and_write_kythe_fact(KytheOutStream), KytheFacts).

:- det(transform_and_write_kythe_fact/2).
transform_and_write_kythe_fact(KytheOutStream, KytheFact) =>
    transform_kythe_fact(KytheFact, KytheFact2),
    pykythe_json_write_dict_nl(KytheOutStream, KytheFact2).

:- det(write_to_protobuf/4).
%! write_to_protobuf(+EntriesCmd, +SrcPath, +KytheJsonPath, +KytheEntriesPath) is det.
write_to_protobuf(EntriesCmd, SrcPath, KytheJsonPath, KytheEntriesPath) =>
    atomic_list_concat( % TODO: use process_create/3 instead of shell/2
        [EntriesCmd,
         " --read_format=json",
         " <", KytheJsonPath,
         " >", KytheEntriesPath],
         Cmd),
    do_if(trace_file(SrcPath), dump_term('CMD-cvt', Cmd)),
    must_once_msg(shell(Cmd, 0), 'Convert to protobuf failed').

:- det(run_parse_cmd/4).
%! run_parse_cmd(+Opts, +SrcPath, +SrcFqn, -OutPath) is det.
% Run the parse command into a temporary file. (The temp file is
% automatically deleted on graceful termination.)
% An alternative would be to run the parse command as a process, into
% a a pipe. This needs more memory, is more complicated to manage, and
% is a bit more difficult to debug.
run_parse_cmd(Opts, SrcPath, SrcFqn, OutPath) =>
    must_be(ground, Opts),
    % TODO: python_version should be triple: see fakesys.FAKE_SYS
    must_once_msg(memberchk(Opts.python_version, [3]), 'Invalid Python version: ~q', [Opts.python_version]),
    setup_call_cleanup(
        true,
        ( pykythe_tmp_file_stream(Opts.kytheout, OutPath, % TODO: mkdir separate subdir for these
                                  OutPathStream, [encoding(binary), extension('fqn-ast.pl')]),
          do_if(trace_file(SrcPath), link_src_file(SrcPath, OutPath)) % TODO: delete
        ),
        close(OutPathStream)
    ),
    atomic_list_concat(  % TODO: use process_create/3 instead of shell/2
        [Opts.parsecmd,
         " --kythe_corpus='", Opts.kythe_corpus, "'",
         " --kythe_root='", Opts.kythe_root, "'",
         " --python_version='", Opts.python_version, "'",
         " --srcpath='", SrcPath, "'",
         " --module='", SrcFqn, "'",
         " --out_fqn_ast='", OutPath, "'"],
        Cmd),
    do_if(trace_file(SrcPath), dump_term('CMD-parse', Cmd)),
    % TODO: An alternative way of doing the following is to have
    % ParseCmd output to stdout and then get it by:
    %   process_create(ParseCmd, ParseCmdArgs, [stdout(pipe(CmdPipe))]),
    %   pykythe_json_read_dict(CmdPipe, ...), ...

    % Note that a syntax error is handled specially, so that it seems
    % to have succeeded at this point, with nothing to analyze. (See
    % process_nodes_impl//2 and the check for 'ParseError'{...} or
    % 'DecodeError'{...}).
    must_once_msg(shell(Cmd, 0), 'Parse-to-AST failed').

:- det(link_src_file/2).
%! link_src_file(+SrcPath:atom, +OutPath:atom) is det.
% For debugging: create a tempfile that is hard-linked
%   to the OutPath from the comand line. The tempfile's
%   name is created from the SrcPath.
% To pretty-print this output for debugging:
% - copy the contents to /tmp/aa.pl
% - surround the contents with j(...).
% - swipl --no-tty /tmp/aa.pl
% - use_module(library(http/json)).
% - j(Z), json_write(current_output, Z).
% TODO: delete this debugging predicate.
link_src_file(SrcPath, OutPath) =>
    re_replace("/"/g, "@", SrcPath, SrcPathSubs), % TODO: pcre: needed to quiet pldoc
    atomic_list_concat(['/tmp/pykythe-parser-output--', SrcPathSubs], TmpParserOutput),
    catch(safe_hard_link_file(OutPath, TmpParserOutput),
          Error,
          log_if(true, 'Failed (~q) to link src file ~q to ~q', [Error, SrcPath, OutPath])).

:- det(version_as_kyfact/3).
%! version_as_kyfact(+Version, +Meta, -KytheFactsAsJsonDict) is det.
% Convert the version into a Kythe fact.
version_as_kyfact(Version, Meta, KytheFactsAsJsonDict) =>
    KytheFactsAsJsonDict = json{source: json{language: Meta.language,
                                             corpus: Meta.kythe_corpus,
                                             root: Meta.kythe_root},
                                fact_name: '/pykythe/version',
                                fact_value: Version}.

:- det(symtab_pykythe_types/4).
%! symtab_pykythe_types(+Symtab)// is det.
% [kyfact,file_meta]
% Generate /pykythe/type facts from the symtab (for debugging).
symtab_pykythe_types(Symtab) ==>>
    Meta/file_meta,
    { append_fqn_dot(Meta.src_fqn, SrcFqnDot) },
    { symtab_pairs(Symtab, SymtabPairs) },
    maplist_kyfact(add_kyfact_types(SrcFqnDot), SymtabPairs).

:- det(add_kyfact_types/5).
%! add_kyfact_types(+Prefix, +FqnType:pair)// is det.
% [kyfact,file_meta]
% Generate kyfact if its FQN (in symtab) starts with Prefix
add_kyfact_types(Prefix, Fqn-Type) ==>>
    (   { has_prefix(Fqn, Prefix) }
        % If we don't want the builtins, do this test:
        %   builtins_pairs(BuiltinsPairs), % inefficient - should use a dict
        %   \+ memberchk(Fqn2-_, BuiltinsPairs),
    ->  { term_to_canonical_atom(Type, TypeAsAtom) },
        signature_node(Fqn, FqnSource),
        kyfact(FqnSource, '/pykythe/type', TypeAsAtom)
    ;   [ ]
    ).

:- det(read_nodes/4).
%! read_nodes(+FqnExprPath:atom, -Nodes, -Meta:dict, -ColorTexts:list(dict)) is det.
% Read the JSON node tree (with FQNs) into Nodes and file meta-data into Meta.
read_nodes(FqnExprPath, Nodes, Meta, ColorTexts) =>
    setup_call_cleanup(
        open(FqnExprPath, read, FqnExprStream, [encoding(octet),type(binary)]),
        (   read_term(FqnExprStream, MetaJson, []),
            read_term(FqnExprStream, NodesJson, []),
            read_term(FqnExprStream, ColorTextsJson, [])
        ),
        close(FqnExprStream)
    ),
    % sanity check that capitalized strings were quoted:
    must_be(ground, MetaJson),
    must_be(ground, NodesJson),
    must_be(ground, ColorTextsJson),
    simplify_meta(MetaJson, Meta),
    simplify_ast(NodesJson, Nodes),
    maplist(simplify_color, ColorTextsJson, ColorTexts).

:- det(simplify_meta/2).
%! simplify_meta(+MetaJson:dict, -Meta:dict) is det.
% Simplify the file meta-data. The argument is the Prolog dict form
% of the first JSON item (see ast_cooked.Meta).
simplify_meta(
    json{
        kind: 'Meta',
        slots: json{
            kythe_corpus: KytheCorpus,
            kythe_root: KytheRoot,
            path: Path,
            language: Language,
            contents_base64: ContentsBase64,
            contents_str: ContentsStr, % TODO: delete (for debugging only)
            contents_bytes: ContentsBytes, % TODO: delete (for debugging only)
            sha1: Sha1,
            encoding: Encoding}},
    Meta) =>
    Meta = meta{
               kythe_corpus: KytheCorpus,
               kythe_root: KytheRoot,
               path: CanonicalPath,
               language: Language,
               encoding: Encoding,
               contents_base64: ContentsBase64,
               contents_str: ContentsStr,
               contents_bytes: ContentsBytes,
               sha1: Sha1,
               src_fqn: _,
               pythonpath: _,
               builtins_module: _,
               opts: _,
               version: _},
    % For debugging, might want to use contents_base64:"LS0t",
    %     derived from:
    %     base64_ascii('---', 'LS0t').
    % Note that keys 'src_fqn', 'pythonpath', 'opts', 'version' get added later
    maybe_canonical_path(Path, CanonicalPath).

:- det(simplify_ast/2).
%! simplify_ast(+Json, -Prolog) is det.
% Simplify the JSON term into more specific dicts, each one
% distinguished by its tag. The input dicts for base types (str, int,
% etc.) are turned into simpler functors.
simplify_ast([], Prolog) => Prolog = [].
simplify_ast([V|Vs], Values) =>
    maplist(simplify_ast, [V|Vs], Values).
% Originally, pod._as_json_dict_full output str, int as wrapped items
% (like bool), but removing the wrapper gave an overall 10%
% performance improvement.
simplify_ast(Value, Value2), atom(Value) => Value2 = Value.
simplify_ast(Value, Value2), integer(Value) => Value2 = Value.
simplify_ast(json{kind: 'bool', value: Value}, Value2) => Value2 = bool(Value).
simplify_ast(json{kind: 'None'}, Value2) => Value2 = none.  % Shouldn't be generated by pod.PlainOldDataExtended.as_json_dict
simplify_ast(json{kind: 'dict', items: Items}, Value) =>
    dict_pairs(Items, _, ItemPairs),
    maplist(simplify_ast_slot_pair, ItemPairs, ItemPairs2),
    dict_pairs(Value, dict, ItemPairs2).
simplify_ast(json{kind: 'Exception', value:ValueStr}, Value2) => Value2 = exception(ValueStr).
simplify_ast(json{kind: Kind, slots: Slots}, Value) =>
    dict_pairs(Slots, _, SlotPairs),
    maplist(simplify_ast_slot_pair, SlotPairs, SlotPairs2),
    dict_pairs(Value, Kind, SlotPairs2).

:- det(simplify_ast_slot_pair/2).
%! simplify_ast_slot_pair(+KeyValue:pair, -KeyValue2:pair) is det.
simplify_ast_slot_pair(Key-Value, KV2) =>
    KV2 = Key-Value2,
    simplify_ast(Value, Value2).

:- det(simplify_color/2).
%! simplify_color(+ColorDictJson:dict, -Color:dict) is det.
% The format from parsecmd is a bit baroque, because it's created
% using a straightforward transformation from the Python (ast_color.Color).
% simplify_color/2 simplifies the data.
% TODO: Generate the simplified form in the Python parser, by adding
%       a suitable as_prolog_str() method to ast_color.Color (and maybe to ast_node.Astn).
simplify_color(json{ kind:'Color',
                     slots:json{ astn:json{ kind:'Astn',
                                            slots:json{end:End,start:Start,value:Value}
                                          },
                                 lineno:Lineno, column:Column,
                                 token_color:TokenColor
                               }
                   },
               Color) =>
    Color = color{start:Start, end:End, value:Value,
                  lineno:Lineno, column:Column,
                  token_color:TokenColor}.

:- det(process_nodes/5).
%! process_nodes(+Nodes, +SrcInfo:dict, -KytheFacts:list, -Exprs:list, +Meta:dict) is det.
% Wrapper for process_nodes//[kyfact,expr,file_meta].
% TODO: separate KytheFacts into those that require de-duping and
%       those that can be simply appended, to minimize the final
%       de-dup.
process_nodes(Node, SrcInfo, KytheFacts, Exprs, Meta) :-
    process_nodes_impl(Node, SrcInfo, KytheFacts, [], Exprs, [], Meta). % phrase(process_nodes(Node), KytheFacts, Exprs, Meta)

:- det(process_nodes_impl/7).
%! process_nodes_impl(+Nodes, +SrcInfor)// is det.
% [kyfact,expr,file_meta]
% Traverse the Nodes, accumulating in KytheFacts (mostly anchors) and
% Expr (which will be traversed later, to fill in dynamically created
% attribtes (e.g., self.foo).
process_nodes_impl(Node, SrcInfo) ==>>
    kyfile(SrcInfo),
    do_if_file(dump_term('NODE', Node)),
    % TODO: return non-zero for parse failure?
    kynode(Node, _Expr).  % _Expr is only used by assignment statements

:- det(kyfile/4).
%! kyfile(+SrcInfo)// is det.
% [kyfact,file_meta]
% Generate the KytheFacts at the file level.
kyfile(SrcInfo) ==>>
    % TODO: output x-numlines, x-html ?
    Meta/file_meta,
    { Meta_path = Meta.path, SrcInfo_src_path = SrcInfo.src_path },
    { assertion(Meta_path == SrcInfo_src_path) },
    { Source = json{corpus: Meta.kythe_corpus, root: Meta.kythe_root, path: Meta.path} },
    % If the following is changed, also change the validation
    % in process_module_cached_impl/7.
    kyfact(Source, '/pykythe/version',     Meta.version),
    kyfact(Source, '/pykythe/text/sha1',   Meta.sha1),
    kyfact(Source, '/kythe/node/kind',     'file'),
    kyfact(Source, '/kythe/text/encoding', Meta.encoding),
    kyfact(Source, '/kythe/language',      python),
    kyfact(Source, '/kythe/text',          Meta.contents_base64),  % Special case - see transform_kythe_fact/2
    kyfact_color_text_as_single_fact(SrcInfo.color_text),
    kyedge_fqn(Source, '/kythe/edge/childof', SrcInfo.src_fqn),
    % Kythe's "package" is the equivalent of Python's "module".
    % (There is no equivalent of Python's "package" ... we just use
    % /kythe/edge/ref/imports on the import statements.)
    kyfact_signature_node(SrcInfo.src_fqn, '/kythe/node/kind', 'package').

:- det(kyfact_color_text_as_single_fact/4).
%! kyfact_color_text_as_single_fact(ColorText)// is det.
% [kyfact,file_meta]
% See src_browser.js for the final form that's used; basically it's a
% list of lines, each line containing a list of items. An item can
% contain edges.
% TODO: KeyedColorText as JSON
kyfact_color_text_as_single_fact(ColorText) ==>>
    % ColorText is list of: color{column:0,end:14,lineno:1,start:0,token_color:'<COMMENT>',value:'# a comment'}
    { maplist(key_color, ColorText, KeyedColorText) },
    % { format(atom(ColorFactText), '~q', [KeyedColorText]) },
    { atom_json_dict(ColorFactText, KeyedColorText,
                     [width(0),true(#(true)),false(#(false)),null(#(null))]) },
    Meta/file_meta,
    kyfact(json{path: Meta.path, language: Meta.language},
           '/pykythe/color_all', ColorFactText).

:- det(key_color/2).
key_color(color{column:Column, end:End, lineno:Lineno, start:Start, token_color:TokenColor, value:Value},
          ColorWithSignature) =>
    ColorWithSignature = color{column:Column, end:End, lineno:Lineno, start:Start, token_color:TokenColor, value:Value, signature:Signature},
    (   is_var_token(TokenColor)
    ->  anchor_signature_str(Start, End, Value, Signature)
    ;   Signature = ''
    ).

%! is_var_token(Str:atom) is semidet.
% If the below changes, also change src_browser:is_var_token
% and src_browser.js token_css_color_class
is_var_token('<ATTR_BINDING>').
is_var_token('<ATTR_REF>').
is_var_token('<PUNCTUATION>').   % TODO: if exists semantic
is_var_token('<PUNCTUATION_REF>'). % This is generated in src_browser.pl
is_var_token('<VAR_BINDING>').
is_var_token('<VAR_BINDING_GLOBAL>').
is_var_token('<VAR_REF>').
% TODO: '<ARG_KEYWORD>'
% TODO: '<BARE>'

:- det(kynode/7).
%! kynode(+Node:json_dict, -Type)// is det.
% [kyfact,expr,file_meta]
% Extract anchors (with FQNs) from the the AST nodes.  The anchors go
% into accumulator 'kyfact' and the expressions (for further
% processing) go into accumulator 'expr'. The predicate returns a
% "type", which is used to populate the right- and left-hand sides of
% assign/2 terms in the 'expr' accumulator (see, e.g.
% 'AssignExprStmt', which calls assign_normalized//2, which uses
% assign_normalized//2.

% (The "type" is in a list, corresponding to a union of types.)

% For nodes that can't appear on the right-hand side of an assignment,
% the "type" is stmt(...) or unused_XXX(...). These values aren't used
% anywhere; they're simply to help with debugging and will cause an
% error in eval_assign_expr//2 if they appear on the r.h.s. of an
% assignment.

% For descriptions of the various types of Node, and how they relate
% to the raw AST, see ast_cooked.py.

% [], [_|_], bool(_), dict(_), 'Astn'{...}' are all handled by
% higher-level nodes. (int, str are already unwrapped)
%   (e.g., 'Astn'{start: Start, end: End, value: Value}}
%   in node_astn/4, which is used by 'ArgumentNode', 'AtomDotNode', etc.;
%   str(_) is used by 'Class', 'Func', etc.)

% assign/2 facts are made up of a left-hand-side (assigned-to) and a
% right-hand-side (expression). These correspond to the LHS and RHS of
% an expression, and have a few variants (note that var_ref(...) on
% the RHS will typically be reduced to a type by evaluation):
%   assign([var_binds(a)], [var_ref(b)]) corresponds to the statement `a = b`
%   assign([var_binds(a)], []) corresponds to the definition of a
%       name, e.g. the `a` in `def foo(a)`
%   assign([dot_op_binds(var_ref(a), b)], [var_ref(c)]) corresponds to
%       `a.b = c`
%   assign([subscr_op_binds(var_ref(a)], [var_ref(b)] corresponds to
%       `a[i] = c` (the `i` isn't used in deriving type information)
% expr/1 facts are like assign/2 but with nothing to assign to.
% expr([]) is a no-op.

% See comments at the top of this file on union and single types.

% The following are handled by the container (e.g., ImportFromStmt):
%   AsNameNode
%   NameBareNode  (from DottedNameNode, ImportFromStmt, etc.)
%   NameNode

% `==>>` (which expands to Picat-style `=>` single-sided unification)
% is used to ensure that the clauses are tried in order, have an
% implicit cut, and if there's a missing case, an error will be
% thrown. The first argument is used for indexing (assuming that
% there's no deep indexing on dicts).

kynode(Node, Type) ==>>
    { is_dict(Node, Tag) },         % extract an atom for indexing
    % TODO: using the Tag for indexing doesn't seem to improve performance.
    %       (jiti_list shows that it is used for indexing).
    kynode(Tag, Node, Type).

:- det(kynode/8).
kynode('AnnAssignStmt',
       'AnnAssignStmt'{left_annotation: LeftAnnotation, expr: Right, left: Left},
       Type) ==>>
    { Type = [stmt(annassign(Left, LeftAnnotation, Right))] },
    % Corresponds to `expr_stmt: testlist_star_expr annassign`.
    % TODO: combine this with 'TypedArgNode' and add test cases
    % TODO: see also 'AssignExprStmt'
    assign_normalized(Left, LeftAnnotation), % DO NOT SUBMIT -- should assign expr_normalized and set type to LeftAnnotation
    assign_normalized(Left, Right).
kynode('ArgumentNode',
       'ArgumentNode'{name: NameAstn, arg: Arg},
       Type) ==>>
    { Type = [todo_arg(Name, ArgType)] },
    % Corresponds to `argument: test '=' test`.  ast_raw creates
    % ArgumentNode only for `test '=' test`; all other cases just
    % generate the expr (or similar)
    % TODO: match Name to func def param
    { node_astn(NameAstn, _, _, Name) },
    kynode(Arg, ArgType).
kynode('AssertStmt',
       'AssertStmt'{items: Items},
       Type) ==>>
     { Type = [stmt(assert)] },
     % Corresponds to `assert_stmt`.
     maplist_kyfact_expr(expr_normalized, Items).
kynode('AssignExprStmt',
       'AssignExprStmt'{expr: Expr, left: Left},
       Type) ==>>
    { Type = [stmt(assign)] },
    assign_normalized(Left, Expr).
kynode('AtomCallNode',
       'AtomCallNode'{args: Args, atom: Atom},
       Type) ==>>
    { Type = [call(AtomType, ArgsTypes)] },
    kynode(Atom, AtomType),
    maplist_kynode(Args, ArgsTypes).
kynode('OpNode',
       'OpNode'{args: Args, op_astns: OpAstns},
       Type) ==>>
    { Type = [call_op(OpAstns, ArgsTypes)] },
    maplist_kynode(Args, ArgsTypes).
kynode('AtomDotNode',
       'AtomDotNode'{atom: Atom, binds: bool('False'), attr_name: AttrNameAstn},
       Type) ==>>
    { Type = [dot_op(AtomType, astn(Start, End, AttrName))] },
    % TODO: eval_atom_dot_single//3 creates /kythe/edge/ref ...
    %       the edge probably should be created here and added to the
    %       dot_op term.
    { node_astn(AttrNameAstn, Start, End, AttrName) },
    kynode(Atom, AtomType).
kynode('AtomDotNode',
       'AtomDotNode'{atom: Atom, binds: bool('True'), attr_name: AttrNameAstn},
       Type) ==>>
    { Type = [dot_op_binds(AtomType, astn(Start,End,AttrName))] },
    % TODO: eval_atom_dot_binds_single//3 creates
    %       /kythe/edge/defines/binding ...  the edge probably should
    %       be created here and added to the dot_op_binds term.
    { node_astn(AttrNameAstn, Start, End, AttrName) },
    kynode(Atom, AtomType).
kynode('AtomSubscriptNode',
       'AtomSubscriptNode'{atom: Atom,
                           binds: bool('False'),
                           subscripts: Subscripts},
       Type) ==>>
    { Type = [subscr_op(AtomType,SubscriptsTypes)] },
    kynode(Atom, AtomType),
    maplist_kynode(Subscripts, SubscriptsTypes).
kynode('AtomSubscriptNode',
       'AtomSubscriptNode'{atom: Atom,
                           binds: bool('True'),
                           subscripts: Subscripts},
       Type) ==>>
    { Type = [subscr_op_binds(AtomType,SubscriptsTypes)] },
    kynode(Atom, AtomType),
    maplist_kynode(Subscripts, SubscriptsTypes).
kynode('AugAssignStmt',
       'AugAssignStmt'{augassign: _OpAstn, expr: Expr, left: Left},
       Type) ==>>
    { Type = [stmt(augassign)] },
    % { node_astn(OpAstn, _, _, _Op) },
    expr_normalized(Left),
    expr_normalized(Expr).
kynode('BreakStmt',
       'BreakStmt'{},
       Type) ==>>
    { Type = [stmt(break)] }.
kynode('Class',
       'Class'{bases: Bases, fqn: Fqn, childof: Childof, name: NameAstn},
       Type) ==>>
    { Type = [class_type(Fqn, BaseTypes)] },
    kyanchor_binding(NameAstn, Fqn, Childof, 'kynode_Class'),
    kyfacts_signature_node(Fqn,
                           ['/kythe/node/kind'-'record',
                            '/kythe/subkind'-'class']),
    maplist_kynode(Bases, BaseTypes),
    [ class_type(Fqn, BaseTypes) ]:expr.
kynode('CompFor',
       'CompFor'{for_exprlist: ForExprlist,
                 in_testlist: InTestlist,
                 comp_iter: CompIter},
       Type) ==>>
    { Type = [todo_compfor(iter:CompIterType,
                           for:ForExprlistType,
                           in:InTestlistType)] },
    % DO NOT SUBMIT - see 'ForStmt' expansion
    kynode(ForExprlist, ForExprlistType),
    kynode(InTestlist, InTestlistType),
    kynode(CompIter, CompIterType).
kynode('CompIfCompIterNode',
       'CompIfCompIterNode'{value_expr: ValueExpr, comp_iter: CompIter},
       Type) ==>>
    { Type = [todo_compifcompiter(ValueExprType, CompIterType)] },
    kynode(ValueExpr, ValueExprType),
    kynode(CompIter, CompIterType).
kynode('ContinueStmt',
       'ContinueStmt'{},
       Type) ==>>
    { Type = [stmt(continue)] }.
kynode('DecoratedStmt',
       'DecoratedStmt'{items: Items},
       Type) ==>>
    { Type = [todo_decorated(ItemsTypes)] },
    maplist_kynode(Items, ItemsTypes).
kynode('DecoratorDottedNameNode',
       'DecoratorDottedNameNode'{items: Items},
       Type) ==>>
    { Type = [todo_decorator_dottedname(ItemsTypes)] },
    { maplist('NameBareNode_astn_and_name', Items, _, ItemsTypes) }.
kynode('DecoratorsNode',
       'DecoratorsNode'{items: Items},
       Type) ==>>
    { Type = [todo_decorators(ItemsTypes)] },
    maplist_kynode(Items, ItemsTypes).
kynode('DelStmt',
       'DelStmt'{items: Items},
       Type) ==>>
    { Type = [stmt(del)] },
    maplist_kyfact_expr(expr_normalized, Items).
kynode('DictGenListSetMakerCompFor',
       'DictGenListSetMakerCompFor'{value_expr: ValueExpr, comp_for: CompFor},
       Type) ==>>
    { Type = [todo_dictgen(ValueExprType, CompForType)] },
    % DO NOT SUBMIT - see 'ForStmt' expansion
    kynode(ValueExpr, ValueExprType),
    kynode(CompFor, CompForType).
kynode('DictKeyValue',
       'DictKeyValue'{items: Items},
       Type) ==>>
    { Type = [todo_dictkeyvaluelist(ItemsTypes)] },
    maplist_kynode(Items, ItemsTypes).
kynode('DictSetMakerNode',
       'DictSetMakerNode'{items: Items},
       % TODO: evaluate the items and create dictset_make of union of items' values' types
       Type) ==>>
    { Type = [dictset_make(ItemsTypes)] },
    % DO NOT SUBMIT - see 'ForStmt' expansion
    maplist_kynode(Items, ItemsTypes).
kynode('EllipsisNode',
       'EllipsisNode'{},
       Type) ==>>
    { Type = [ellipsis] }.
kynode('ExceptClauseNode',
       'ExceptClauseNode'{expr: Expr, as_item: AsItem},
       Type) ==>>
    { Type = [stmt(except)] },
    kynode(Expr, ExprType),
    kynode(AsItem, AsItemType),
    (   { type_omitted(AsItemType) }
    ->  [ expr(ExprType) ]:expr
    ;   [ assign(AsItemType, ExprType) ]:expr
    ).
kynode('ExprListNode',
       'ExprListNode'{items: Items, binds: bool('False')},
       Type) ==>>
    { Type = [exprlist(ItemsTypes)] },
    maplist_kynode(Items, ItemsTypes).
kynode('ExprListNode',
       'ExprListNode'{items: Items, binds: bool('True')},
       Type) ==>>
    { Type = [exprlist_binds(ItemsTypes)] },
    % TODO: exprlist_binds and list_of_type_binds should be the same?
    maplist_kynode(Items, ItemsTypes).
kynode('ExprStmt',
       'ExprStmt'{expr: Expr},
       Type) ==>>
    { Type = [stmt(assign)] },
    kynode(Expr, ExprType),
    [ expr(ExprType) ]:expr.
kynode('FileInput',
       'FileInput'{scope_bindings: _ScopeBindings, stmts: Stmts, path: _Path},
       Type) ==>>
    { Type = [stmt(file)] },
    % kynode(ScopeBindings, _),
    maplist_kynode(Stmts, _).
kynode('ForStmt',
       'ForStmt'{for_exprlist: ForExprlist,
                 in_testlist: InTestlist,
                 suite: Suite,
                 else_suite: ElseSuite},
       Type) ==>>
    { Type = [stmt(for)] },
    kynode('AssignExprStmt',
           'AssignExprStmt'{
                   expr:'AtomSubscriptNode'{atom: InTestlist,
                                            binds: bool('False'),
                                            subscripts: ['NumberIntNode'{}]},
                   left: ForExprlist},
           _),
    kynode(ElseSuite, _),
    kynode(Suite, _).
kynode('Func',
       'Func'{fqn: Fqn,
              name: NameAstn,
              childof: Childof,
              parameters: Params,
              return_type: Return},
       Type) ==>>
    { Type = [stmt(function(Fqn,ParamsTypes,ReturnType))] },
    % Similar to 'Method'{...}
    kyanchor_binding(NameAstn, Fqn, Childof, 'kynode_Func'),
    kyfact_signature_node(Fqn, '/kythe/node/kind', 'function'),
    maplist_kynode(Params, ParamsTypes),
    kynode(Return, ReturnType),
    [ function_type(Fqn,ParamsTypes,ReturnType) ]:expr.
kynode('GlobalStmt',
       'GlobalStmt'{items: Items},
       Type) ==>>
    { Type = [stmt(global)] },
    maplist_kyfact_expr(expr_normalized, Items).
kynode('IfStmt',
       'IfStmt'{eval_results: EvalResults, items: Items},
       Type) ==>>
    { Type = [stmt(if)] },
    kynode_if_stmt(EvalResults, Items).
kynode('ImportFromStmt',
       'ImportFromStmt'{from_dots: FromDots,
                        import_part: ImportPart,
                        childof: Childof},
       Type) ==>>
    % The parser doesn't output a field if it's None, so add from_name
    % and recurse.
    kynode('ImportFromStmt',
           'ImportFromStmt'{from_dots: FromDots,
                            from_name: 'DottedNameNode'{items:[]},
                            import_part: ImportPart,
                            childof: Childof},
           Type).
kynode('ImportFromStmt',
       'ImportFromStmt'{from_dots: FromDots,
                        from_name: FromName,
                        import_part: 'ImportAsNamesNode'{items: ImportPartItems},
                        childof: Childof},
       Type) ==>>
    { Type = [unused_import('ImportFromStmt',Types)] },
    maplist_kyfact_expr(kyImportFromStmt(FromDots, FromName, Childof), ImportPartItems, Types).
kynode('ImportFromStmt',
       'ImportFromStmt'{from_dots: FromDots,
                        from_name: FromName,
                        import_part: 'StarFqn'{star:StarAstn, fqn:StarFqn},
                        childof: Childof},
       Type) ==>>
    % TODO: process this properly
    % For the '*' part, set up binds for __all__ variables.
    % We need to record this information so that var_binds_lookup etc behave
    % correctly in the 2nd pass.
    { ImportPartItems = [
        'AsNameNode'{as_name:'NameBindsFqn'{fqn:StarFqn, name:StarAstn, childof: Childof},
                     name:'NameBareNode'{name:StarAstn}}] },
    { ImportPart = 'ImportAsNamesNode'{items: ImportPartItems} },
    kynode('ImportFromStmt',
           'ImportFromStmt'{from_dots: FromDots,
                            from_name: FromName,
                            import_part: ImportPart,
                            childof: Childof},
           Type).
kynode('ImportNameFqn',
       'ImportNameFqn'{dotted_as_names: 'ImportDottedAsNamesFqn'{items: DottedAsNames}},
       Type) ==>>
    { Type = [unused_import('ImportNameFqn',DottedAsNamesTypes)] },
    maplist_kyfact_expr(kyImportDottedAsNamesFqn, DottedAsNames, DottedAsNamesTypes).
kynode('IfExpr',
       'IfExpr'{cond_expr: CondExpr, then_expr: ThenExpr, else_expr: ElseExpr},
       Type) ==>>
    { Type = [if_expr(CondType,ThenType,ElseType)] },
    kynode(CondExpr, CondType),
    kynode(ThenExpr, ThenType),
    kynode(ElseExpr, ElseType).
kynode('ListMakerNode',
       'ListMakerNode'{items: Items, binds: bool('False')},
       Type) ==>>
    { Type = [list_make(ItemsTypes)] },
    maplist_kynode(Items, ItemsTypes).
kynode('ListMakerNode',
       'ListMakerNode'{items: Items, binds: bool('True')},
       Type) ==>>
    { Type = [list_make_binds(ItemsTypes)] },
    maplist_kynode(Items, ItemsTypes).
kynode('Method',
       'Method'{fqn: Fqn,
                name: NameAstn,
                childof: Childof,
                parameters: Params,
                return_type: Return},
       Type) ==>>
    { Type = [stmt(method(Fqn,ParamsTypes,ReturnType))] },
    % Similar to 'Func'{...}
    kyanchor_binding(NameAstn, Fqn, Childof, 'kynode_Method'),
    kyfact_signature_node(Fqn, '/kythe/node/kind', 'function'),
    (   { node_astn(NameAstn, _, _, Name) },
        (   { Name = '__init__' ; Name = '__new__' ; Name = '__post_init__' } )
    ->  kyfact_signature_node(Fqn, '/kythe/subkind', 'constructor')
    ;   kyfact_signature_node(Fqn, '/kythe/subkind', 'method') % TODO: add to Kythe schema
    ),
    maplist_kynode(Params, ParamsTypes),
    kynode(Return, ReturnType),
    [ method_type(Fqn,ParamsTypes,ReturnType) ]:expr.
% 'NameBindsFqn' is only for 'AssignExprStmt' -- for import statements,
% it's handled separately.
% TODO: special case this within processing of AssignExprStmt?
kynode('NameBindsFqn',
       'NameBindsFqn'{fqn: Fqn, name: NameAstn, childof: Childof},
       Type) ==>>
    { Type = [var_binds(Fqn)] },  % result is same as NameRefFqn
    kyanchor_binding(NameAstn, Fqn, Childof, 'kynode_NameBindsFqn'), % only difference from NameRef
    kyfact_signature_node(Fqn, '/kythe/node/kind', 'variable').
kynode('NameBindsUnknown',
       'NameBindsUnknown'{fqn_stack: FqnStack, name: NameAstn, childof: _Childof},
       Type) ==>>
    { Type = [var_binds_lookup(FqnStack, NameAstn)] },
    % kyedge_fqn_fqn(Fqn, '/kythe/edge/childof', Childof),
    [ ].  % /kythe/edge/ref edge will be added in eval_single_type//2.
kynode('NameRefFqn',
       'NameRefFqn'{fqn: Fqn, name: NameAstn},
       Type) ==>>
    { Type = [var_ref(Fqn)] },  % result is same as NameRefFqn
    kyanchor_node_kyedge_fqn(NameAstn, '/kythe/edge/ref', Fqn). % only difference from NameBindsFqn
kynode('NameRefGenerated',
       'NameRefGenerated'{fqn: Fqn},
       Type) ==>>
    { Type = [var_ref(Fqn)] },  % result is same as NameBinds
    % TODO: This occurs inside TypedArgNode, which needs to be implemented.
    [ ].  % E.g., the implicit type for `self`.
kynode('NameRefUnknown',
       'NameRefUnknown'{fqn_stack: FqnStack, name: NameAstn},
       Type) ==>>
    { Type = [var_ref_lookup(FqnStack, NameAstn)] },
    [ ].  % The /kythe/edge/ref edge will be added in eval_single_type//2.
kynode('NonLocalStmt',
       'NonLocalStmt'{items: Items},
       Type) ==>>
    { Type = [stmt(nonlocal)] },
    maplist_kyfact_expr(expr_normalized, Items).
kynode('NumberComplexNode',
       'NumberComplexNode'{astn: _Astn},
       ComplexType) ==>>
    { builtins_symtab_primitive(complex, ComplexType) }.
kynode('NumberFloatNode',
       'NumberFloatNode'{astn: _Astn},
       FloatType) ==>>
    { builtins_symtab_primitive(float, FloatType) }.
kynode('NumberIntNode',
       'NumberIntNode'{astn: _Astn},
       IntType) ==>>
    { builtins_symtab_primitive(int, IntType) }.
kynode('NumberIntNode',
       'NumberIntNode'{},
       IntType) ==>>  % from ForStmt etc
    { builtins_symtab_primitive(int, IntType) }.
kynode('OmittedNode',
       'OmittedNode'{},
       Type) ==>>
    { Type = [omitted] }.
kynode('PassStmt',
       'PassStmt'{},
       Type) ==>>
    { Type = [stmt(break)] }.
kynode('RaiseStmt',
       'RaiseStmt'{items: Items},
       Type) ==>>
    { Type = [stmt(raise)] },
    maplist_kynode(Items, _).
kynode('StarNode',
       'StarNode'{},
       Type) ==>>  % TODO: can we get rid of this in ast_cooked?
    { Type = [star] }.
kynode('Stmts',
       'Stmts'{items: Items},
       Type) ==>>
    { Type = [stmt(stmts)] },
    maplist_kynode(Items, ItemsTypes),
    kynode_add_items(ItemsTypes).
kynode('StringNode',
       'StringNode'{astns: _Astns},
       StrType) ==>>
    { builtins_symtab_primitive(str, StrType) }.
kynode('StringBytesNode',
       'StringBytesNode'{astns: _Astns},
       BytesType) ==>>
    { builtins_symtab_primitive(bytes, BytesType) }.
% subscript only occurs inside subscr_op or subscr_op_binds and is
% ignored (we only care about the resulting type)
kynode('SubscriptNode',
       'SubscriptNode'{expr1: Expr1, expr2: Expr2, expr3: Expr3},
       Type) ==>>
    { Type = [subscript(Expr1Type, Expr2Type, Expr3Type)] },
    kynode(Expr1, Expr1Type),
    kynode(Expr2, Expr2Type),
    kynode(Expr3, Expr3Type).
% kynode('TnameNode', 'TnameNode'{name: Name, type_expr: TypeType} isn't needed
% because it's always inside TypedArgNode.
kynode('TryStmt',
       'TryStmt'{items: Items},
       Type) ==>>
    { Type = [stmt(try)] },
    maplist_kynode(Items, _).
kynode('TypedArgNode',
       'TypedArgNode'{tname: 'TnameNode'{name: Name, type_expr: TypeExpr},
                      expr: Expr},
       Type) ==>>
    { Type = [] },
    % TODO: is this correct? Need test cases with all variants
    %       PROBABLY should be union of TypeExpr, Expr
    %       but for now, just output [] (Any)
    % TODO: see also 'AnnAssignStmt'
    assign_normalized(Name, TypeExpr),
    assign_normalized(Name, Expr).  % Can cause duplicate facts, which are removed elsewhere
kynode('WhileStmt',
       'WhileStmt'{else_suite: ElseSuite,
                   suite: Suite,
                   test: Test},
       Type) ==>>
    { Type = [stmt(while)] },
    kynode(ElseSuite, _),
    kynode(Suite, _),
    kynode(Test, _).
kynode('WithItemNode',
       'WithItemNode'{item: Item, as_item: AsItem},
       Type) ==>>
    { Type = [stmt(with_item)] },
    kynode(Item, ItemType),
    kynode(AsItem, AsItemType),
    (   { type_omitted(AsItemType) }
    ->  [ expr(ItemType) ]:expr
    ;   [ assign(AsItemType, ItemType) ]:expr
    ).
kynode('WithStmt',
       'WithStmt'{items: Items, suite: Suite},
       Type) ==>>
    { Type = [stmt(with)] },
    maplist_kynode(Items, _),   % handled by WithItemNode
    kynode(Suite, _).
% The following are error results:
kynode('ParseError',
       ParseError, % 'ParseError'{context: Context, msg: Msg, type: Type, value: Value, srcpath: SrcPath}
       Type) ==>>
    { Type = [parse_error(ParseError)] },
    [ parse_error(ParseError) ]:expr.
kynode('DecodeError',
       DecodeError, % 'DecodeError'{encoding:Encoding, start:Start, end:End, reason:Reason, srcpath: SrcPath}
       Type) ==>>
    { Type = [decode_error(DecodeError)] },
    [ decode_error(DecodeError) ]:expr.
kynode('Crash',
       CrashError, % 'Crash'{repr: Repr, str: Str, srcpath: SrcPath}
       Type) ==>>
    { Type = [crash(CrashError)] },
    [ crash(CrashError) ]:expr.

:- det(kynode_add_items/6).
%! kynode_add_items(Items:list)// is det.
% [kyfact,expr,file_meta]
kynode_add_items([]) ==>> [ ].
kynode_add_items([I|Is]) ==>>
    kynode_add_items2(I),
    kynode_add_items(Is).

:- det(kynode_add_items2/6).
kynode_add_items2([]) ==>> [ ].
kynode_add_items2(I), ? { I = [_|_] } ==>> % TODO: seems to be a kludge for handling union type
    kynode_add_items(I).
kynode_add_items2(I) ==>> [ I ]:expr.

:- det(kynode_if_stmt/7).
%! kynode_if_stmt(+Results:list, +Items:list)// is det.
% [kyfact,expr,file_meta]
kynode_if_stmt([], []) ==>> [ ]. % No 'else'
kynode_if_stmt([], [ElseItem]) ==>>
    kynode(ElseItem, _).
kynode_if_stmt(['EvalResult'{result:bool('True')}|_], [Cond,ThenItem|ElseItems]) ==>> % if/elif True
    { if_stmt_elses(ElseItems, ElseItemsConds) },
    maplist_kynode([Cond, ThenItem | ElseItemsConds], _).
kynode_if_stmt(['EvalResult'{result:bool('False')}|Results], [Cond,_Then|Items]) ==>> % if/elif False
    kynode(Cond, CondType),
    kynode_add_items(CondType),
    kynode_if_stmt(Results, Items).
kynode_if_stmt(['EvalResult'{exception:_Exc}|Results], [Cond,Item|Items]) ==>> % if/elif Exception
    % We don't know if this is true or not, so assume true and continue with the result
    maplist_kynode([Cond,Item], CondItemType),
    kynode_add_items(CondItemType),
    kynode_if_stmt(Results, Items).

:- det(if_stmt_elses/2).
%! if_stmt_elses(+Items, -ElseItems) is det.
% Extract the "conds" from an IfStmt (removing the "then"s and "else"s)
if_stmt_elses([], ElseItems) => ElseItems = [].
if_stmt_elses([_ElseItem], ElseItems) => ElseItems = [].
if_stmt_elses([Cond,_ThenItem|ElseItems0], ElseItems) =>
    ElseItems = [Cond|ElseItemsConds],
    if_stmt_elses(ElseItems0, ElseItemsConds).

:- det(kyanchor_binding/7).
kyanchor_binding(NameAstn, Fqn, Childof, DebugInfo) ==>>
    log_if_file('KYANCHOR_BINDING(~w) ~p ~q ~q', [DebugInfo, NameAstn, Fqn, Childof]),
    kyedge_fqn_fqn(Fqn, '/kythe/edge/childof', Childof),
    kyanchor_node_kyedge_fqn(NameAstn, '/kythe/edge/defines/binding', Fqn).

:- det(kyanchor_binding/9).
kyanchor_binding(Start, End, AttrName, Fqn, Childof, DebugInfo) ==>>
    log_if_file('KYANCHOR_BINDING(~w) ~q:~q,~q ~q ~q', [DebugInfo, AttrName, Start, End, Fqn, Childof]),
    kyedge_fqn_fqn(Fqn, '/kythe/edge/childof', Childof),
    kyanchor_kyedge_fqn(Start, End, AttrName, '/kythe/edge/defines/binding', Fqn).

% === IMPORT and FROM-IMPORT ===

% Design decision: No need for /kythe/edge/ref/file anywhere except for undefined
% files that we can't resolve - just /kythe/edge/ref/imports
%      - the file itself will have
%          File=vname("", _, _, FileName, "").node/kind file)
%          Pkg=vname(PkgName, _, _, "", python).node/kind package
%          File childof Pkg
% Note that for "from foo.bar import zot as qqsv", the file is
% foo/bar.py or foo/bar/__init__.py or foo/bar/zot.py but the
% (/kythe/edge/ref/imports is always foo.bar.zot (this might be a
% reference to a module ("package" in Kythe-speak) or an individual
% item within a module).
%
% An import statement generates the following facts:
%     ref/imports      - corresponds to the file (foo.bar)
%     defines/binding  - what gets added to the symtab
% Details are given with each clause (below) and in the test cases.

:- det(kyImportDottedAsNamesFqn/7).
%! kyImportDottedAsNamesFqn(+DottedName, -DottedAsNamesTypes)// is det.
% [kyfact,expr,file_meta]
% Corresponds to a single item from `dotted_as_names`: "import" and "import ... as ...".
% The Fqn is either the top-level of the import (e.g., "os" in "import os.path")
% or the "as" name (e.g., "os_path" in "import os.path as os_path").
% This code is similar to kyImportFromStmt, but deviates in a few places:
% - Leading dots (relative imports) are not allowed by the grammar.
% - "import foo.bar" adds "foo" to the symtab; but "import foo.bar as foo_bar" adds
%   "foo_bar".
% * from foo.bar import zot [as qqsv]
%     @foo  ref/imports      foo
%     @bar  ref/imports      foo.bar
%     @zot  ref/imports      foo.bar.zot
%     @foo  defines/binding  $FQN.foo
%     @zot  defines/binding  $FQN.zot  [$FQN.qqsv]
% NOTE: there are some weird corner cases ... for example, "import
%       os.path" gets a name in /usr/lib/python3.9/os.py that happens
%       to be a module but alternatively gets
%       typeshed/stdlib/os/path.pyi ... we therefore have to allow
%       for module_alone and module_and_token everywhere.
kyImportDottedAsNamesFqn('ImportDottedFqn'{
                             dotted_name: 'DottedNameNode'{items: DottedNameItems},
                             top_name: 'NameBindsFqn'{fqn: BindsFqn, name: BindsNameAstn, childof: _Childof}},
                         DottedAsNamesTypes) ==>>
    { DottedAsNamesTypes = unused_import('ImportDottedFqn',BindsFqn) },
    % From "import os" or "import os.path" or "import os.path.sep"
    % BindsFqn is just the "top name" (e.g., "${FQN}.os" for
    % "os.path") so don't need to do anything special for it.
    kyImportDottedAsNamesFqn_top(DottedNameItems, BindsFqn, BindsNameAstn).
kyImportDottedAsNamesFqn('ImportDottedAsNameFqn'{
                             dotted_name: 'DottedNameNode'{items: DottedNameItems},
                             as_name: 'NameBindsFqn'{fqn: BindsFqn, name: BindsNameAstn, childof: _Childof}},
                         DottedAsNamesTypes) ==>>
    { DottedAsNamesTypes = unused_import('ImportDottedAsNameFqn',BindsFqn) },
    % From "import foo as baz" or "import foo.bar as baz"
    kyImportDottedAsNamesFqn_as([], % FromDots
                                DottedNameItems, BindsFqn, BindsNameAstn).
kyImportDottedAsNamesFqn('ImportDottedAsNameFqn'{
                             dotted_name: 'DottedNameNode'{items: DottedNameItems},
                             as_name: 'NameBindsUnknown'{fqn_stack: FqnStack, name: BindsNameAstn, childof: _Childof}},
                         DottedAsNamesTypes) ==>>
    { DottedAsNamesTypes = unused_import('ImportDottedAsNameFqn',BindsNameAstn:FqnStack) },
    % From "global baz; import foo as baz" or "global baz; import foo.bar as baz"
    kyImportDottedAsNamesFqn_as_unknown([], % FromDots
                                        DottedNameItems, FqnStack, BindsNameAstn).

:- det(kyImportFromStmt/10).
%! kyImportFromStmt(+FromDots:list, +FromName, +Childof, +AsNameNode, -ImportPart)// is det.
% [kyfact,expr,file_meta]
% Corresponds to a single item of `import_from`: "from ... import ..."
% TODO: (excluding "from ... import *", to be handled by kyImportFromStmt_star).
%
% This predicate called from a maplist over the import parts, which
% means that the FromDots and FromName will be re-processed for each
% item. This is slightly inefficient but it simplifies things because
% the processing of FromDots and FromName depends on the import part
% (in "from foo import bar", we could be processing foo/bar.py or
% foo.py and the token "bar").
% - FromDots is zero or more  ImportDotNode's.
% - FromName is none or DottedNameNode.
% If there are no ImportDotNode's, then the result is
% $PYTHONPATH/Path/To/From/Pat/ImportPart.
% If there are ImportDotNode's, then the result is
% FilePath/ImportPart, where FilePath is derived from the Meta
% information for the file, followed by '/..' as needed.
kyImportFromStmt(FromDots,
                 'DottedNameNode'{items:DottedNameItems},
                 Childof,
                 'AsNameNode'{name:BareNameAstn, % 'NameBareNode'{name:NameAstn},
                              as_name:'NameBindsFqn'{fqn: BindsFqn, name: AsNameAstn, childof: Childof}},
                 ImportPart) ==>>
    { ImportPart = unused_import('AsNameNode',BindsFqn) },
    % From "from foo import baz [as zot]" and many variations
    { append(DottedNameItems, [BareNameAstn], DottedNameItemsComb) -> true }, % else fail
    kyImportDottedAsNamesFqn_as(FromDots,
                                DottedNameItemsComb, BindsFqn, AsNameAstn).
kyImportFromStmt(FromDots,
                 'DottedNameNode'{items:DottedNameItems},
                 Childof,
                 'AsNameNode'{name:BareNameAstn, % 'NameBareNode'{name:NameAstn},
                              as_name:'NameBindsUnknown'{fqn_stack: FqnStack, name: AsNameAstn, childof: Childof}},
                 ImportPart) ==>>
    { ImportPart = unused_import('AsNameNode',AsNameAstn) },
    % From "global zot; from foo import baz as zot" and many variations
    { append(DottedNameItems, [BareNameAstn], DottedNameItemsComb) -> true }, % else fail
    kyImportDottedAsNamesFqn_as_unknown(FromDots,
                                        DottedNameItemsComb, FqnStack, AsNameAstn).

:- det(kyImportDottedAsNamesFqn_top/8).
%! kyImportDottedAsNamesFqn_top(+DottedNameItems:list, +BindsFqn:atom, +BindsNameAstn:astn)// is det.
% [kyfact,expr,file_meta]
kyImportDottedAsNamesFqn_top(DottedNameItems, BindsFqn, BindsNameAstn) ==>>
    kyImportDottedAsNamesFqn_from_part(DottedNameItems,
                                       [], % FromDots,
                                       ModulesAndMaybeTokenToImport),
    { DottedNameItems = ['NameBareNode'{name:BindsNameAstn}|_] },
    { node_astn(BindsNameAstn, _, _, TopName) },
    kyImport_path_pieces_to_module([], % FromDots
                                   [TopName], ModuleAndMaybeTokenAssignImport, _TopModulePieces),
    { AssignImport = assign_import{binds_fqn: BindsFqn,
                                   module_and_maybe_token: ModuleAndMaybeTokenAssignImport,
                                   modules_to_import: ModulesAndMaybeTokenToImport
                                  } },
    % TODO: childof DO NOT SUBMIT
    kyanchor_node_kyedge_fqn(BindsNameAstn, '/kythe/edge/defines/binding', BindsFqn),
    [ AssignImport ]:expr.

:- det(add_up_dirs/3).
add_up_dirs([], SrcParts0, SrcParts) => SrcParts = SrcParts0.
add_up_dirs([FromDot|FromDots], SrcParts0, SrcParts) =>
    kyImportDotNode_to_astn(FromDot, _, _), % verify it's what we expect
    append(SrcParts0, ['..'], SrcParts1),
    add_up_dirs(FromDots, SrcParts1, SrcParts).

:- det(kyImportDottedAsNamesFqn_as/9).
%! kyImportDottedAsNamesFqn_as(+FromDots, +DottedNameItems:list, +BindsFqn:atom, +BindsNameAstn:astn)// is det.
% [kyfact,expr,file_meta]
kyImportDottedAsNamesFqn_as(FromDots, DottedNameItems, BindsFqn, BindsNameAstn) ==>>
    kyImportDottedAsNamesFqn_from_part(DottedNameItems, FromDots, ModulesAndMaybeTokenToImport),
    { node_astn(BindsNameAstn, Start, End, Token) },
    { last(ModulesAndMaybeTokenToImport, FMP) },
    { full_module_part(FMP, FMPname) },
    kyanchor_kyedge_fqn(Start, End, Token, '/kythe/edge/ref/imports', FMPname),
    { AssignImport = assign_import{binds_fqn: BindsFqn,
                                   module_and_maybe_token: FMP,
                                   modules_to_import: ModulesAndMaybeTokenToImport
                                  } },
    % TODO: childof DO NOT SUBMIT
    kyanchor_node_kyedge_fqn(BindsNameAstn, '/kythe/edge/defines/binding', BindsFqn),
    [ AssignImport ]:expr.

:- det(kyImportDottedAsNamesFqn_as_unknown/9).
%! kyImportDottedAsNamesFqn_as_unknown(+FromDots, +DottedNameItems:list, +FqnStack:list(atom), +BindsNameAstn:astn)// is det.
% [kyfact,expr,file_meta]
kyImportDottedAsNamesFqn_as_unknown(FromDots, DottedNameItems, FqnStack, BindsNameAstn) ==>>
    % TODO: this is cut&paste from kyImportDottedAsNamesFqn_as//4 - refactor
    %       the common part
    kyImportDottedAsNamesFqn_from_part(DottedNameItems, FromDots, ModulesAndMaybeTokenToImport),
    { node_astn(BindsNameAstn, Start, End, Token) },
    { last(ModulesAndMaybeTokenToImport, FMP) },
    { full_module_part(FMP, FMPname) },
    kyanchor_kyedge_fqn(Start, End, Token, '/kythe/edge/ref/imports', FMPname),
    { AssignImport = assign_import_unknown{fqn_stack: FqnStack,
                                           binds_astn: BindsNameAstn,
                                           module_and_maybe_token: FMP,
                                           modules_to_import: ModulesAndMaybeTokenToImport
                                          } },
    % /kythe/edge/defines/binding will be added in eval_single_type//2.
    [ AssignImport ]:expr.

:- det(kyImportDottedAsNamesFqn_from_part/8).
%! kyImportDottedAsNamesFqn_from_part(+NameItems:list, +FromDots:list, -ModulesAndMaybeTokenToImport:list)// is det.
% [kyfact,expr,file_meta]
kyImportDottedAsNamesFqn_from_part(NameItems, FromDots, ModulesAndMaybeTokenToImport) ==>>
    kyImportDottedAsNamesFqn_from_part2(NameItems, FromDots, [], ModulesAndMaybeTokenToImport).

:- det(kyImportDottedAsNamesFqn_from_part2/9).
%! kyImportDottedAsNamesFqn_from_part2(+NameItems:list, +FromDots:list, +SoFar:list, -ModulesAndMaybeTokenToImport:list)// is det.
% [kyfact,expr,file_meta]
kyImportDottedAsNamesFqn_from_part2([], _FromDots, _SoFar, ModulesAndMaybeTokenToImport) ==>>
    { ModulesAndMaybeTokenToImport = [] }.
kyImportDottedAsNamesFqn_from_part2(['NameBareNode'{name:Astn}|NameItems], FromDots, SoFar,
                                    ModulesAndMaybeTokenToImport) ==>>
    { ModulesAndMaybeTokenToImport = [ModuleAndMaybeToken|MAMTs] },
    { append(SoFar, [Name], SoFar2) -> true }, % else fail
    { node_astn(Astn, Start, End, Name) },
    kyImport_path_pieces_to_module(FromDots,
                                   SoFar2, ModuleAndMaybeToken, FullModulePieces),
    { join_fqn(FullModulePieces, FMPname) },
    kyanchor_kyedge_fqn(Start, End, Name, '/kythe/edge/ref/imports', FMPname),
    kyImportDottedAsNamesFqn_from_part2(NameItems, FromDots, SoFar2, MAMTs).

:- det(kyImport_path_pieces_to_module/9).
%! kyImport_path_pieces_to_module(+FromDots:list, +NamePieces:list, -ModuleAndMaybeToken, -FullModulePieces:list)// is det.
% [kyfact,expr,file_meta]
% Process components of an "import" statement to the module name
% and output ref/imports edges for the path components.
kyImport_path_pieces_to_module(FromDots, NamePieces, ModuleAndMaybeToken, FullModulePieces) ==>>
    Meta/file_meta,
    { join_path(NamePieces, FullPath) },
    { full_path(FromDots, FullPath, Meta.pythonpath, Meta.path, ModuleAndMaybeToken, FullModulePieces) },
    kyImport_path_dots(FromDots).

:- det(kyImport_path_dots/6).
%! kyImport_path_dots(+FromDots)// is det.
% [kyfact,expr,file_meta]
% Add Kythe ref/imports edges for the dotted items in a path.
kyImport_path_dots([]) ==>> [ ].
kyImport_path_dots([FromDot0|FromDots]) ==>>
    Meta/file_meta,
    { FromDot0 = 'ImportDotNode'{dot:DotAstn} },
    { node_astn(DotAstn, Start, End, '.') },
    { full_path([FromDot0|FromDots], '', [], Meta.path, FMP, _ModulePieces) },
    { full_module_part(FMP, FMPname) },
    kyanchor_kyedge_fqn(Start, End, '.', '/kythe/edge/ref/imports', FMPname),
    kyImport_path_dots(FromDots).

:- det('NameBareNode_astn_and_name'/3).
%! 'NameBareNode_astn_and_name'(+DottedNameItem, -DottedName) is det.
% Process a NameBareNode node into a name
'NameBareNode_astn_and_name'('NameBareNode'{name: NameAstn}, NameAstn, Name) =>
    node_astn(NameAstn, _, _, Name).

:- det(kyImportDotNode_to_astn/3).
%! kyImportDotNode(+Node, -Astn, -Name:atom) is det.
kyImportDotNode_to_astn('ImportDotNode'{dot:DotAstn}, Astn, Name) =>
    Astn = astn(Start, End, Name),
    node_astn(DotAstn, Start, End, Name).

:- det(maplist_kynode/7).
%! maplist_kynode(+Nodes, -NodesTypes:list)// is det.
% [kyfact,expr,file_meta]
% equivalent to: maplist_kyfact_expr(kynode, Nodes, NodesTypes)
% TODO: for some reason this fails when maplist meta-predicate is used
%       (maybe due to handling of _? in a meta-call?)
maplist_kynode([], NodeTypesOut) ==>>
    { NodeTypesOut = [] }.
maplist_kynode([Node|Nodes], NodeTypesOut) ==>>
    { NodeTypesOut = [NodeType|NodesTypes] },
    kynode(Node, NodeType),
    maplist_kynode(Nodes, NodesTypes).

:- det(assign_normalized/7).
%! assign_normalized(+Left, +Right)// is det.
% [kyfact,expr,file_meta]
% Process the Left and Right parts of an assign/2 term, handling
% things like `omitted` and `ellipsis`.
assign_normalized(Left, Right) ==>>
    kynode(Left, LeftType),
    kynode(Right, RightType),
    assign_normalized2(LeftType, RightType).

:- det(assign_normalized2/7).
assign_normalized2(LeftType, _RightType), ? { type_omitted(LeftType) } ==>> [ ].
assign_normalized2(LeftType, RightType), ? { type_omitted_or_ellipsis(RightType) } ==>>
    [ assign(LeftType, []) ]:expr.
assign_normalized2(LeftType, RightType) ==>>
    [ assign(LeftType, RightType) ]:expr.

:- det(expr_normalized/6).
%! expr_normalized(+Right)// is det.
% [kyfact,expr,file_meta]
% Process the Right parts of an expr/1 term, handling
% things like `omitted` and `ellipsis`.
expr_normalized(Right) ==>>
    kynode(Right, RightType),
    (   { type_omitted_or_ellipsis(RightType) }
    ->  [ ]
    ;   [ expr(RightType) ]:expr
    ).

%! type_omitted_or_ellipsis(+Type) is multi.
% Succeeds if Type = [omitted] ; Type = [ellipsis]
type_omitted_or_ellipsis([T]) :-
    omitted_or_ellipsis(T).
omitted_or_ellipsis(omitted).
omitted_or_ellipsis(ellipsis).

%! type_omitted is semidet.
type_omitted([omitted]).

%! node_astn(+AstnNode, -Start, -End, -Value) is semidet.
%! node_astn(-AstnNode, +Start, +End, +Value) is det.
% Access the inner parts of an Astn node.
% See also portray/1 rule for 'Astn' (uses node_astn/4).
node_astn('Astn'{start: Start, end: End, value: Value},
           Start, End, Value).

:- det(kyanchor_kyedge_fqn/8).
%! kyanchor_kyedge_fqn(+Start:int, +End:int, +Token:atom, +EdgeKind:atom, +Fqn:atom)// is det.
% [kyfact,file_meta]
kyanchor_kyedge_fqn(Start, End, Token, EdgeKind, Fqn) ==>>
    kyanchor(Start, End, Token, Source),
    kyedge_fqn(Source, EdgeKind, Fqn).

:- det(kyanchor_node_kyedge_fqn/6).
%! kyanchor_node_kyedge_fqn(+Astn, +EdgeKind:atom, +Fqn:atom, -Token)// is det.
% [kyfact,file_meta]
kyanchor_node_kyedge_fqn(Astn, EdgeKind, Fqn, Token) ==>>
    kyanchor_node(Astn, Source, Token),
    kyedge_fqn(Source, EdgeKind, Fqn).

:- det(kyanchor_node_kyedge_fqn/7).
%! kyanchor_node_kyedge_fqn(+Astn, +EdgeKind:atom, +Fqn:atom)// is det.
% [kyfact,file_meta]
kyanchor_node_kyedge_fqn(Astn, EdgeKind, Fqn) ==>>
    kyanchor_node(Astn, Source),
    kyedge_fqn(Source, EdgeKind, Fqn).

:- det(kyanchor_node/5).
%! kyanchor_node(+Astn, -Source)// is det.
% [kyfact,file_meta]
kyanchor_node(Astn, Source) ==>>
    kyanchor_node(Astn, Source, _Token).

:- det(kyanchor_node/6).
%! kyanchor_node(+Astn, -Source, -Token)// is det.
% [kyfact,file_meta]
kyanchor_node(Astn, Source, Token) ==>>
    { node_astn(Astn, Start, End, Token) },
    kyanchor(Start, End, Token, Source).

:- det(kyanchor/7).
%! kyanchor(+Start, +End, Token, -Source)// is det.
% [kyfact,file_meta]
% Create the Kythe facts for an anchor. Source gets the source signature.
kyanchor(Start, End, Token, Source) ==>>
    % The following is only true for pure ascii input; with utf8,
    % the Start is in *bytes*, so the substring test isn't necessarily true
    % { $(sub_string(Meta.contents_str, Start, Len, _, Token)) },
    { anchor_signature_str(Start, End, Token, Signature) },
    signature_source(Signature, Source),
    % https://github.com/kythe/kythe/issues/1725
    % - there is no need to generate kyedge(Source, '/kythe/edge/childof', json{path: Meta.path})
    kyfact(Source, '/kythe/node/kind', 'anchor'),
    kyfact(Source, '/kythe/loc/start', Start),
    kyfact(Source, '/kythe/loc/end', End).

:- det(anchor_signature_str/2).
anchor_signature_str('Astn'{start:Start, end:End, value:Token}, Signature) =>
    anchor_signature_str(Start, End, Token, Signature).

:- det(anchor_signature_str/4).
anchor_signature_str(Start, End, Token, Signature) :-
    format(atom(Signature), '@~d:~d<~w>', [Start, End, Token]).  % DO NOT SUBMIT (this format is for debugging)
    % format(atom(Signature), '@~d', [Start]).

:- det(kyedge_fqn_fqn/6).
%! kyedge_fqn_fqn(+Fqn1:atom, +EdgeKind:atom, +Fqn2:atom)// is det.
% [kyfact,file_meta]
% High-level create a Kythe edge fact from an FQN to a target
% identified by an FQN.
% If EdgeKind is '', do nothing
kyedge_fqn_fqn(_, '', _) ==>> [ ].  % For conditional output
kyedge_fqn_fqn(Fqn1, EdgeKind, Fqn2) ==>>
    signature_node(Fqn1, Source1),
    signature_node(Fqn2, Source2),
    kyedge(Source1, EdgeKind, Source2).

:- det(kyedge_fqn/6).
%! kyedge_fqn(+Source:dict, +EdgeKind:atom, +Fqn:atom)// is det.
% [kyfact,file_meta]
% High-level create a Kythe edge fact to a target identified by an
% FQN.  Source is a partial dict for generating JSON; corpus and root
% are filled in from file_meta.
kyedge_fqn(Source, EdgeKind, Fqn) ==>>
    signature_node(Fqn, Target),
    kyedge(Source, EdgeKind, Target).

:- det(kyedge/6).
%! kyedge(+Source:dict, +EdgeKind:atom, +Target:atom)// is det.
% [kyfact,file_meta]
% Low-level create a Kythe edge fact -- for both Source and Target,
% corpus and root are filled in from file_meta (these are partial
% dict's, for generating JSON).
kyedge(Source, EdgeKind, Target) ==>>
    Meta/file_meta,
    [ json{source: Source.put(corpus, Meta.kythe_corpus).put(root, Meta.kythe_root),
           edge_kind: EdgeKind,
           target: Target.put(corpus, Meta.kythe_corpus).put(root, Meta.kythe_root),
           fact_name: '/'} ]:kyfact.

:- det(kyfacts/5).
%! kyfacts(+Vname, FactValues:list)// is det.
% [kyfact,file_meta]
% kyfact over a list of FactName-FactValue
kyfacts(_Vname, []) ==>> [ ].
kyfacts(Vname, [FactName-FactValue|FactValues]) ==>>
    kyfact(Vname, FactName, FactValue),
    kyfacts(Vname, FactValues).

:- det(kyfact/6).
%! kyfact(+Source:dict, +FactName, +FactValue)// is det.
% [kyfact,file_meta]
% Low-level create a Kythe fact edge -- Source is a partial dict for
% generating JSON; corpus and root are filled in from file_meta.
kyfact(Source, FactName, FactValue) ==>>
    Meta/file_meta,
    [ json{source: Source.put(corpus, Meta.kythe_corpus).put(root, Meta.kythe_root),
           fact_name: FactName, fact_value: FactValue} ]:kyfact.

:- det(signature_source/3).
%! signature_source(+Signature:string, -Source)// is det.
% [file_meta]
% Create a Kythe "source" tuple from a Signature string.
signature_source(Signature, Source) ==>>
    Meta/file_meta,
    { Source = json{signature: Signature, path: Meta.path, language: Meta.language} }.

:- det(diagnostic_source/3).
%! diagnostic_source(+AnchorSignature:string, -Source)// is det.
% [file_meta]
% Generate a unique diagnostic ID from the anchor's signature
diagnostic_source(AnchorSignature, Source) ==>>
    Meta/file_meta,
    { atomic_list_concat(['<diagnostic>', AnchorSignature], GensymBase) },
    { gensym(GensymBase, DiagnosticSignature) },
    { Source = json{signature: DiagnosticSignature, path: Meta.path, language: Meta.language} }.

:- det(kyfact_signature_node/6).
%! kyfact_signature_node(+AnchorSignature:string, +FactName, +FactValue)// is det.
% [kyfact,file_meta is det.
kyfact_signature_node(AnchorSignature, FactName, FactValue) ==>>
    signature_node(AnchorSignature, Vname),
    kyfact(Vname, FactName, FactValue).

:- det(kyfacts_signature_node/5).
%! kyfacts_signature_node(+AnchorSignature:string, +FactValues:list)// is det.
% [kyfact,file_meta]
kyfacts_signature_node(AnchorSignature, FactValues) ==>>
    signature_node(AnchorSignature, Vname),
    kyfacts(Vname, FactValues).

:- det(signature_node/3).
%! signature_node(+AnchorSignature:string, -Vname)// is det.
% [file_meta]
% Create a Kythe "vname" from a AnchorSignature string
signature_node(AnchorSignature, Vname) ==>>
    Meta/file_meta,
    { Vname = json{signature: AnchorSignature, language: Meta.language} }.

:- det(kyfact_attr/6).
%! kyfact_attr(+FqnAttr:atom, +AttrAstn, +Type) is det.
% This can generate duplicate facts because FqnAttr can happen in
% multiple places.
kyfact_attr(FqnAttr, astn(Start,End,Attr), Type) ==>>
    { term_string(Type, TypeStr) },
    signature_node(FqnAttr, FqnAttrSource),
    kyanchor_kyedge_fqn(Start, End, Attr, '/kythe/edge/ref', FqnAttr),
    kyfact(FqnAttrSource, '/pykythe/type', TypeStr).

%%%%%%        %%%%%%%
%%%%%% Pass 2 %%%%%%%
%%%%%%        %%%%%%%

:- det(assign_exprs/6).
%! assign_exprs(+Opts:list, +Exprs:list, +Meta:dict, +Symtab0:dict, -Symtab:dict, -KytheFacts:list) is det.
% Process a list of Exprs, generating a Symtab (by adding to initial
% Symtab0) and a list of KytheFacts.
assign_exprs(Opts, Exprs, Meta, Symtab0, Symtab, KytheFacts) :-
    assign_exprs_count(1, Opts, Exprs, Meta, Symtab0, Symtab, KytheFacts).

:- det(assign_exprs_count/7).
%! assign_exprs_count(+Count, +Opts:list, +Exprs:list, +Meta:dict, +Symtab0:dict, -Symtab:dict, -KytheFacts:list) is det.
% Process a list of Exprs, generating a Symtab (by adding to initial
% Symtab0) and a list of KytheFacts.
% `Count` tracks the number of passes over Exprs; if too large, the
% processing stops. In most cases, three passes suffice.
% TODO: Improved output when too many passes are needed.
% TODO: Parameterize max number of passes.
assign_exprs_count(Count, Opts, Exprs, Meta, Symtab0, Symtab, KytheFacts) :-
    assign_exprs_count_impl(Exprs, Meta, Symtab0, Symtab1, Rej, KytheFacts1), % phrase(assign_exprs_count(...))
    length(Rej, RejLen),
    log_if(true, % RejLen > 0, % TODO: Output Pass# with RejLen = 0 for performance profiling.
           'Process exprs: Pass ~q (rej=~q) for ~q', [Count, RejLen, Meta.path]),
    CountIncr is Count + 1,
    (   (   Rej = [] ; CountIncr > 5) % TODO: parameterize.
    ->  Symtab = Symtab1,
        KytheFacts = KytheFacts1,
        pairs_keys(Rej, RejKeys),
        sort(RejKeys, RejKeysSorted),
        % The write_term is to guard against "circular" types, e.g.
        %     list_of_type([list_of_type([]), ...)
        % (These will eventually get fixed, of course.)
        with_output_to(
            string(RejStr),
            write_term(current_output, Rej,
                       [quoted(true), portray(true), max_depth(10), attributes(portray)])),
        log_if(Rej \= [], 'Max pass count exceeded: ~d leaving ~d unprocessed: ~q -- ~w',
                          [CountIncr, RejLen, RejKeysSorted, RejStr])
        % log_if(Rej \= [], 'Rejected: ~q', [Rej])
    ;   log_if(trace_file(Meta.path), 'REJ: ~q', [Rej]),
        pairs_values(Rej, RejTypes0),
        % TODO: DO NOT SUBMIT - use union_type??
        append(RejTypes0, RejTypes1), % make union of all the included types
        include(is_module, RejTypes1, RejModules0),
        sort(RejModules0, RejModules),
        log_if(trace_file(Meta.path), 'REJ-MODULES: ~q', [RejModules]),
        foldl_process_module_cached_or_from_src(Opts, 'from src ok', RejModules, Symtab1, Symtab1WithImports),
        assign_exprs_count(CountIncr, Opts, Exprs, Meta, Symtab1WithImports, Symtab, KytheFacts)
    ).

:- det(assign_exprs_count_impl/6).
%! assign_exprs_count_impl(+Exprs, +Meta:dict, +Symtab0:dict, -SymtabWithRej:dict, -Rej:dict, -KytheFacts) is det.
% Helper for assign_exprs_count, which does the actual processing.
assign_exprs_count_impl(Exprs, Meta, Symtab0, SymtabWithRej, Rej, KytheFacts) :-
    maplist_eval_assign_expr(Exprs, KytheFactsList, [],
                             sym_rej(Symtab0,[]), sym_rej(SymtabAfterEval,Rej), Meta),
    list_to_set(KytheFactsList, KytheFacts),
    % TODO: is the following needed? The accumulator should have
    %       already added the types to the symtab.
    foldl(add_rej_to_symtab, Rej, SymtabAfterEval, SymtabWithRej),
    assertion(SymtabAfterEval == SymtabWithRej).

:- det(maplist_eval_assign_expr/6).
%! maplist_assign_exprs_eval(+Assign:list)// is det.
% [kyfact,symrej,file_meta]
% Process a list of assign or eval nodes.
maplist_eval_assign_expr([]) ==>> [ ].
maplist_eval_assign_expr([Assign|Assigns]) ==>>
    do_if_file(dump_term('(EVAL_ASSIGN_EXPR)', Assign)),
    eval_assign_expr(Assign),
    !, % "cut" for memory usage *** THIS ONE IS IMPORTANT ***
    % symtab_if_file('SYMTAB'),   % TODO: delete
    maplist_eval_assign_expr(Assigns).

:- det(eval_assign_expr/6).
%! eval_assign_expr(+Node)// is det.
% [kyfact,symrej,file_meta]
% Process a single assign/2 or expr/1 node.
eval_assign_expr(assign(BindsLeft, Right)) ==>>
    % TODO: e.g.: _S = TypeVar('_S')
    %             => assign([var_binds('.home.peter.src.typeshed.stdlib.collections._S')], [call([var_ref('.home.peter.src.typeshed.stdlib.collections.TypeVar')],[['.home.peter.src.typeshed.stdlib.builtins.str']])])
    eval_union_type(Right, RightEval),
    eval_union_type(BindsLeft, BindsLeftEval),
    maplist_kyfact_symrej(eval_assign_single(RightEval, BindsLeft), BindsLeftEval).
eval_assign_expr(expr(Right)) ==>>
    eval_union_type(Right, _RightEval).
eval_assign_expr(class_type(BindsFqn, Bases)) ==>>
    maplist_kyfact_symrej(eval_union_type, Bases, BasesEvals0),
    { clean_class(BindsFqn, BasesEvals0, BasesEvals) },
    [ BindsFqn-[class_type(BindsFqn, BasesEvals)]-_ ]:symrej.
eval_assign_expr(function_type(BindsFqn,Params,Return)) ==>>  % Similar to method_type(...)
    eval_union_type(Return, ReturnEval),
    maplist_kyfact_symrej(eval_union_type, Params, ParamsEvals),
    [ BindsFqn-[function_type(BindsFqn,ParamsEvals,ReturnEval)]-_ ]:symrej.
eval_assign_expr(method_type(BindsFqn,Params,Return)) ==>>  % Similar to func_type(...)
    eval_union_type(Return, ReturnEval),
    maplist_kyfact_symrej(eval_union_type, Params, ParamsEvals),
    [ BindsFqn-[function_type(BindsFqn,ParamsEvals,ReturnEval)]-_ ]:symrej.
eval_assign_expr(import_ref_type(_Name, _Fqn, Type)) ==>>
    eval_assign_expr(Type).
eval_assign_expr(stmt(_)) ==>> [ ].
eval_assign_expr(unused_import(_,_)) ==>> [ ].
eval_assign_expr(unused_import(_,_,_)) ==>> [ ].
eval_assign_expr(assign_import{binds_fqn: BindsFqn,
                               module_and_maybe_token: ModuleAndMaybeToken,
                               modules_to_import: ModulesAndMaybeToken
                              }) ==>>
    % /kythe/edge/defines/binding has been done in kynode//2
    { full_module_part(ModuleAndMaybeToken, ModuleDotToken) },
    [ ModuleDotToken-BindsType-_ ]:symrej, % lookup the module(+token)
    [ BindsFqn-BindsType-_ ]:symrej,
    % Add the modules to symtab, and the item they bind to. This is
    % so that all the imports will be done (by being extracted by
    % modules_in_symtab/2 and then processed by
    % foldl_process_module_cached_or_from_src/5 in
    % maybe_process_module_cached_impl/7).
    maplist_kyfact_symrej(eval_assign_import, ModulesAndMaybeToken).
eval_assign_expr(assign_import_unknown{fqn_stack: FqnStack,
                                       binds_astn: BindsNameAstn,
                                       module_and_maybe_token: _ModuleAndMaybeToken,
                                       modules_to_import: ModulesAndMaybeToken
                                      }) ==>>
    maplist_kyfact_symrej(eval_assign_import, ModulesAndMaybeToken),
    resolve_unknown_fqn(FqnStack, BindsNameAstn, ResolvedBindsFqn, _Type),
    % TODO: childof DO NOT SUBMIT
    kyanchor_node_kyedge_fqn(BindsNameAstn, '/kythe/edge/defines/binding', ResolvedBindsFqn).
eval_assign_expr(Expr) ==>>  % catch-all
    eval_single_type(Expr, _).

:- det(eval_assign_import/6).
%! eval_assign_import(+ModuleAndMaybeToken)// is det.
% [kyfact,symrej,file_meta]
% Puts entries into symtab. Only the first FqnBind is needed, but it doesn't
% hurt to put unused names; all the modules need to be added to the symtab, for
% getting picked up modules_in_symtab/2 in maybe_process_module_cached_impl/7.
eval_assign_import(import_ref_type(_Name, _Fqn, ModuleAndMaybeToken)) ==>>
    eval_assign_import(ModuleAndMaybeToken).
eval_assign_import(ModuleAndMaybeToken) ==>>
    { module_to_module_alone(ModuleAndMaybeToken, ModuleAlone, ModuleFqn) },
    [ ModuleFqn-[module_type(ModuleAlone)]-_ ]:symrej.

:- det(eval_assign_single/8).
%! eval_assign_single(+RightEval, +BindsLeft, +BindsLeftEval)// is det.
% [kyfact,symrej,file_meta]
% Helper for a single assignment. The order of args is because of how maplist works.
eval_assign_single(RightEval, _BindsLeft, var_binds(BindsFqn)) ==>>
    % Anchor and /kythe/edge/defines/binding edge have already been done by kynode//2.
    [ BindsFqn-RightEval-_ ]:symrej.
eval_assign_single(RightEval, _BindsLeft, var_ref(Fqn)) ==>>
    % Can occur from subscr_op_binds, e.g. foo[i] = bar
    % because foo is not in a binding context (it's a ref)_
    % There should already be a /kythe/edge/ref edge from kynode//2.
    [ Fqn-RightEval-_ ]:symrej.
eval_assign_single(RightEval, BindsLeft, dot_op_binds(AtomType, AttrAstn)) ==>>
    maplist_kyfact_symrej(eval_assign_dot_op_binds_single(RightEval, AttrAstn, BindsLeft), AtomType).
eval_assign_single(RightEval, _BindsLeft, subscr_op_binds(AtomType,SubscriptsTypes)) ==>>
    maplist_kyfact_symrej(eval_union_type, SubscriptsTypes, _SubscriptsTypesEval),
    maplist_kyfact_symrej(eval_assign_subscr_op_binds_single(RightEval), AtomType).
eval_assign_single(_RightEval, _BindsLeft, BindsLeftEval) ==>>
    % l.h.s. is of a form that we can't process.
    % TODO: handle list_of_type_binds (struct unpacking)
    { memberchk(BindsLeftEval, [var_binds(_), dot_op_binds(_, _), subscr_op_binds(_),
                                list_of_type_binds(_), exprlist_binds(_)]) }.
  % One cause for getting here is if ast_raw didn't set the binding
  % context properly.  This happens if the l.h.s. is in the symtab
  % and evaluates to something (e.g., class_type(...)).
  % e.g. (if the "as"  expr in "with" is evaluated in a REF context):
  %    x = ''; with foo() as x: bar(x)
  % =============

:- det(eval_assign_subscr_op_binds_single/7).
%! eval_assign_subscr_op_binds_single(+RightEval, +AtomType) is det.
eval_assign_subscr_op_binds_single(RightEval, var_ref(BindsFqn)) ==>>
    % TODO: Add the following; but this requires removing
    %       cycles, e.g. caused by this (from functools._lru_cache_wrapper):
    %       `root = []; root[:] = [root, root]`
    % TODO: Circular list_of_type([list_of_type([]),...) seems to come
    %       from somewhere else also; see /usr/lib/python3.9/typing.py
    %       and show the Rej in the "Max pass count exceeded" message.
    (   symtab_lookup(BindsFqn, Type), % TODO: remove this hack
        { member(list_of_type(Type2), Type) },
        { member(list_of_type(_), Type2) }
    ->  [ ]
    ;   [ BindsFqn-[list_of_type(RightEval)]-_ ]:symrej
    ).
eval_assign_subscr_op_binds_single(_RightEval, _) ==>> [ ].

:- det(eval_assign_dot_op_binds_single/9).
%! eval_assign_dot_op_binds_single(+RightEval, +AttrAstn, +BindsLeft, +AtomType)// is det.
% [kyfact,symrej,file_meta]
eval_assign_dot_op_binds_single(RightEval, astn(Start,End,AttrName), _BindsLeft, class_type(ClassName,_Bases)) ==>>
    % TODO: should subclasses that don't override this get anything?
    { join_fqn([ClassName, AttrName], BindsFqn) },
    [ BindsFqn-RightEval-_ ]:symrej,
    kyanchor_binding(Start, End, AttrName, BindsFqn, ClassName, 'eval_assign_dot_op_binds_single/class_type').
eval_assign_dot_op_binds_single(RightEval, astn(Start,End,AttrName), _BindsLeft, function_type(FunctionName,Params, Return)) ==>>
    % TODO: use builtins.function's definition, if it exists,
    %       otherwise allow adding a new attr.
    eval_union_type(Return, _),
    maplist_kyfact_symrej(eval_union_type, Params, _),
    { join_fqn([FunctionName, AttrName], BindsFqn) },
    [ BindsFqn-RightEval-_ ]:symrej,
    kyanchor_binding(Start,End, AttrName, BindsFqn, FunctionName, 'eval_assign_dot_op_binds_single/function_type').
eval_assign_dot_op_binds_single(RightEval, astn(Start,End,AttrName), _BindsLeft, module_type(module_alone(Module,_Path))) ==>>
    { join_fqn([Module, AttrName], BindsFqn) },
    [ BindsFqn-RightEval-_ ]:symrej,
    kyanchor_binding(Start, End, AttrName, BindsFqn, Module, 'eval_assign_dot_op_binds_single/module_type').
eval_assign_dot_op_binds_single(RightEval, astn(Start,End,AttrName), _BindsLeft, module_type(module_and_token(Module,_Path,Token))) ==>>
    { join_fqn([Module, Token, AttrName], BindsFqn) },
    [ BindsFqn-RightEval-_ ]:symrej,
    kyanchor_binding(Start, End, AttrName, BindsFqn, Module, 'eval_assign_dot_op_binds_single/module_type'). % TODO: verify this DO NOT SUBMIT
eval_assign_dot_op_binds_single(RightEval, AttrAstn, BindsLeft, import_ref_type(_Name, _Fqn, AtomType)) ==>>
    eval_assign_dot_op_binds_single(RightEval, AttrAstn, BindsLeft, AtomType).
eval_assign_dot_op_binds_single(RightEval, AttrAstn, BindsLeft, AtomType) ==>>
    % Catch-all
    % Typically _AtomType is [] because we don't have enough
    % information to figure out the type.
    { AttrAstn = astn(_Start, _End, AttrName) },
    possible_classes_from_attr(AttrName, Classes),
    log_possible_classes_from_attr('binds', AttrAstn, Classes, AtomType),
    eval_assign_dot_op_binds_single2(RightEval, AttrAstn, BindsLeft, Classes).

:- det(eval_assign_dot_op_binds_single2/9).
eval_assign_dot_op_binds_single2(RightEval, AttrAstn, _BindsLeft, Classes),
    ? { Classes \= [] },
    ? { AttrAstn = astn(Start, End, AttrName) } ==>>
    kyanchor(Start, End, AttrName, Source),
    maplist_kyfact_symrej(eval_assign_dot_op_binds_unknown(Source, AttrName, RightEval), Classes).
eval_assign_dot_op_binds_single2(RightEval, AttrAstn, BindsLeft, Classes),
    ? { Classes = [] } ==>>
    log_kyfact_msg(AttrAstn,
                   'WARNING: eval_assign_dot_op_binds_single failed', [],
                   'no rule for ~q', [eval_assign_dot_op_binds_single('RightEval'=RightEval, 'BindsLeft'=BindsLeft)]),
    % Typically arrive here if there is a union of types and one of them doesn't
    % support the "dot" operator. e.g. (on 2nd pass):
    %    source.prefix = " "; source = [source]
    % TODO: compare with eval_atom_dot_single
    % TODO: and eval_assign_single(_, dot_op_binds([], AttrAstn))
    [ ].

:- det(eval_assign_dot_op_binds_unknown/9).
%! eval_assign_dot_op_binds_unknown(+Source, +AttrName, +RightEval, +Class)// is det.
% [kyfact,symrej,file_meta]
eval_assign_dot_op_binds_unknown(Source, AttrName, RightEval, class_type(ClassName,_)) ==>>
    { join_fqn([ClassName, AttrName], FqnAttr) },
    % DO NOT SUBMIT - make new kyanchor_binding for this:
    log_if_file('EVAL_ASSIGN_DOT_OP_BINDS_UNKNOWN(class_type) ~p ~q ~q', [Source, FqnAttr, ClassName]),
    kyedge_fqn_fqn(FqnAttr, '/kythe/edge/childof', ClassName),
    kyedge_fqn(Source, '/kythe/edge/defines/binding', FqnAttr),
    [ FqnAttr-RightEval-_ ]:symrej.
eval_assign_dot_op_binds_unknown(Source, AttrName, RightEval, import_ref_type(_Name, _Fqn, AtomType)) ==>>
    eval_assign_dot_op_binds_unknown(Source, AttrName, RightEval, AtomType).
eval_assign_dot_op_binds_unknown(_Source, _AttrName, _RightEval, module_type(_Module)) ==>> [ ].
eval_assign_dot_op_binds_unknown(Source, AttrName, RightEval, function_type(Fqn,_Parms,_Return)) ==>>
    { join_fqn([Fqn, AttrName], FqnAttr) },
    % DO NOT SUBMIT - make new kyanchor_binding for this:
    log_if_file('EVAL_ASSIGN_DOT_OP_BINDS_UNKNOWN(function_type) ~p ~q ~q', [Source, FqnAttr, Fqn]),
    kyedge_fqn_fqn(FqnAttr, '/kythe/edge/childof', Fqn),
    kyedge_fqn(Source, '/kythe/edge/defines/binding', FqnAttr),
    [ FqnAttr-RightEval-_ ]:symrej.
eval_assign_dot_op_binds_unknown(_Source, _AttrName, _RightEval, _Class) ==>>
    % A weird case can arrise with @property (which we
    % don't currently process), in which a function is treated as a list/dict.
    % Typically, Class = list_of_type(ElementType)
    % TODO: handle @property and add a catch-all here?
    % TODO: Issue #23
    % See also eval_dot_unknown.
    [ ].

:- det(eval_dot_op_unknown/8).
%! eval_dot_op_unknown(+Source, +AttrName, +Type)// is det.
% [kyfact,symrej,file_meta]
% TODO: combine with eval_assign_dot_op_binds_unknown
eval_dot_op_unknown(Source, AttrName, class_type(ClassName,_)) ==>>
    { join_fqn([ClassName, AttrName], FqnAttr) },
    kyedge_fqn(Source, '/kythe/edge/ref', FqnAttr),
    [ FqnAttr-[]-_ ]:symrej.
eval_dot_op_unknown(Source, AttrName, module_type(Module)) ==>>
    { module_part(Module, ModuleName) },
    { join_fqn([ModuleName, AttrName], FqnAttr) },
    (   symtab_lookup(FqnAttr, _)
    ->  kyedge_fqn(Source, '/kythe/edge/ref', FqnAttr)
        % DO NOT SUBMIT -- add /pykythe/type from lookup (and also for binds)
    ;   [ ]
    ).
eval_dot_op_unknown(Source, AttrName, import_ref_type(_Name, _Fqn, AtomType)) ==>>
    eval_dot_op_unknown(Source, AttrName, AtomType).
eval_dot_op_unknown(Source, AttrName, function_type(Fqn,_Params,_Return)) ==>>
    { join_fqn([Fqn, AttrName], FqnAttr) },
    kyedge_fqn(Source, '/kythe/edge/ref', FqnAttr),
    [ FqnAttr-[]-_ ]:symrej.
eval_dot_op_unknown(_Source, _AttrName, _Class) ==>>
    % A weird case can arrise with @property (which we
    % don't currently process), in which a function is treated as a list/dict.
    % Typically, Class = list_of_type(ElementType)
    % TODO: handle @property and add a catch-all here?
    % TODO: Issue #23
    % See also eval_assign_dot_unknown.
    [ ].

:- det(eval_union_type/7).
%! eval_union_type(+Expr, -UnionEvalType)// is det.
% [kyfact,symrej,file_meta]
% Evaluate (union) Expr and look it up in the symtab.
eval_union_type(Expr, UnionEvalType) ==>>
    maplist_kyfact_symrej_union(eval_single_type, Expr, UnionEvalType).

:- det(eval_single_type/7).
%! eval_single_type(+Expr, -UnionEvalType)// is det.
% [kyfact,symrej,file_meta]
% Evaluate (non-union) Expr, including look up in the symtab.
eval_single_type(var_ref(Fqn), UnionEvalType) ==>>
    % TODO: could call symtab_lookup(Fqn, UnionEvalType)
    %       to avoid weird code in symrej_accum: ( Type = [] -> true ; true )
    % /kythe/edge/ref edge was created by kynode//2.
    [ Fqn-UnionEvalType-_ ]:symrej.
eval_single_type(var_binds(BindsFqn), UnionEvalType) ==>>
    { UnionEvalType = [var_binds(BindsFqn)] },
    % /kythe/edge/defines/binding edge was created by kynode//2.
    [ ].
eval_single_type(var_binds_lookup(FqnStack, NameAstn), UnionEvalType) ==>>
    % TODO: remove? This probably doesn't happen.
    % TODO: check "global", "local" test cases
    % If there is a global binding, the non need for lookup.
    % If there's no global binding, then there will be only var_ref_lookup's.
    resolve_unknown_fqn(FqnStack, NameAstn, ResolvedBindsFqn, UnionEvalType),
    [ ResolvedBindsFqn-UnionEvalType-_ ]:symrej,
    % DO NOT SUBMIT -- need test case -- is it the same as VAR_REF_LOOKUP?
    % TODO: childof?
    (   { UnionEvalType = [] }
    ->  eval_single_type_import(NameAstn, ResolvedBindsFqn, '/kythe/edge/defines/binding', '/kythe/edge/childof', [])
    ;   maplist_kyfact_symrej(eval_single_type_import(NameAstn, ResolvedBindsFqn, '/kythe/edge/defines/binding', '/kythe/edge/childof'), UnionEvalType)
    ).
eval_single_type(var_ref_lookup(FqnStack, NameAstn), UnionEvalType) ==>>
    resolve_unknown_fqn(FqnStack, NameAstn, ResolvedRefFqn, UnionEvalType),
    % We know that there are no entries in symrej from kynode//2
    % because if a name was resolved by the Python code, it wouldn't
    % generate 'NameRefUnknown' (which creates var_ref_lookup).
    [ ResolvedRefFqn-UnionEvalType-_ ]:symrej,
    (   { UnionEvalType = [] }
    ->  eval_single_type_import(NameAstn, ResolvedRefFqn, '/kythe/edge/ref', '', [])
    ;   maplist_kyfact_symrej(eval_single_type_import(NameAstn, ResolvedRefFqn, '/kythe/edge/ref', ''), UnionEvalType)
    ).
eval_single_type(class_type(ClassName, Bases0), UnionEvalType) ==>>
    { UnionEvalType = [class_type(ClassName, Bases)] },
    maplist_kyfact_symrej(eval_union_type, Bases0, Bases1),
    { clean_class(ClassName, Bases1, Bases) }.
eval_single_type(function_type(FuncName,Params,Return), UnionEvalType) ==>>
    { UnionEvalType = [function_type(FuncName,ParamsTypes,ReturnType)] },
    maplist_kyfact_symrej(eval_union_type, Params, ParamsTypes),
    eval_union_type(Return, ReturnType).
eval_single_type(module_type(ModuleAndMaybeToken), UnionEvalType) ==>>
    { UnionEvalType = [module_type(ModuleAndMaybeToken)] }.
eval_single_type(import_ref_type(_Name, _Fqn, Type), UnionEvalType) ==>>
    eval_single_type(Type, UnionEvalType).
eval_single_type(dot_op(Atom, AttrAstn), UnionEvalType) ==>>
    eval_union_type(Atom, AtomEval0),
    % TODO: bindings.py: @7579-7589<capitalize>
    %                    @8700-8702<mx> (2nd mx)
    (   { AtomEval0 = [] }
    ->  % Don't know what the atom is, so the best we can do is
        % 'object'.  But there's no need to special case 'object'
        % because it's in builtins (which is always imported), and
        % we'll also get other common types such as 'str' by looking in
        % there.
        { AttrAstn = astn(Start, End, AttrName) },
        % TODO: special handling of super().__init__ (see test_data/c3_a.py)
        possible_classes_from_attr(AttrName, Classes),
        log_possible_classes_from_attr('ref', AttrAstn, Classes, AtomEval0),
        kyanchor(Start, End, AttrName, Source),
        maplist_kyfact_symrej(eval_dot_op_unknown(Source, AttrName), Classes),
        { AtomEval = AtomEval0 } % TODO: - use maplist(Classes)
    ;   { AtomEval = AtomEval0 }
    ),
    maplist_kyfact_symrej_union(eval_atom_dot_single(AttrAstn), AtomEval, UnionEvalType).
eval_single_type(if_expr(_CondExpr,ThenExpr,ElseExpr), UnionEvalType) ==>>
    eval_union_type(ThenExpr, ThenEvalType),
    eval_union_type(ElseExpr, ElseEvalType),
    { combine_types([ThenEvalType, ElseEvalType], UnionEvalType) }.
eval_single_type(function_type(Name,Params,Return), UnionEvalType) ==>>
    { UnionEvalType = [function_type(Name,ParamsEvals,ReturnEval)] },
    maplist_kyfact_symrej(eval_union_type, Params, ParamsEvals),
    eval_union_type(Return, ReturnEval).
eval_single_type(dot_op_binds(Atom, AttrAstn), UnionEvalType) ==>>
    { UnionEvalType = [dot_op_binds(AtomEval, AttrAstn)] },
    eval_union_type(Atom, AtomEval).
eval_single_type(subscr_op_binds(Atom,Subscripts), UnionEvalType) ==>>
    { UnionEvalType = [subscr_op_binds(AtomEval,SubscriptsEval)] },
    % This is used by eval_asssign_expr, which further processes it.
    maplist_kyfact_symrej(eval_union_type, Subscripts, SubscriptsEval),
    maplist_kyfact_symrej_union(eval_atom_subscr_binds_single, Atom, AtomEval).
eval_single_type(subscr_op(Atom,Subscripts), UnionEvalType) ==>>
    maplist_kyfact_symrej(eval_union_type, Subscripts, _),
    eval_union_type(Atom, AtomEval0),
    (   { AtomEval0 = [] }
    ->  % don't know what the atom is, so the best we can do is 'object':
        { builtins_symtab_primitive(object, AtomEval) } % TODO: Issue #18
    ;   { AtomEval = AtomEval0 }
    ),
    maplist_kyfact_symrej_union(eval_atom_subscr_single, AtomEval, UnionEvalType).
eval_single_type(call(Atom, Args), UnionEvalType) ==>>
    eval_union_type(Atom, AtomEval),
    maplist_kyfact_symrej(eval_union_type, Args, ArgsEval),
    maplist_kyfact_symrej_union(eval_atom_call_single(ArgsEval), AtomEval, UnionEvalType).
eval_single_type(call_op(_OpAstns, ArgsTypes), UnionEvalType) ==>>
    maplist_kyfact_symrej(eval_union_type, ArgsTypes, _ArgsTypesEval),
    % See typeshed/stdlib/operator.pyi
    { UnionEvalType = [] }.
eval_single_type(ellipsis, UnionEvalType) ==>>
    { UnionEvalType = [] }.
eval_single_type(module(Fqn, Path), UnionEvalType) ==>>
    { UnionEvalType = [module(Fqn,Path)] }.
eval_single_type(omitted, UnionEvalType) ==>>
    { UnionEvalType = [] }.

% TODO: expand all of the following.
%   Check http://localhost:8888/#/tmp/pykythe_test/SUBST/home/peter/src/pykythe/pykythe/ast_raw.py?root=ROOT&corpus=CORPUS&signature&line=262
% TODO: implement the following:
eval_single_type(todo_compfor(iter:CompIterType, for:ForExprlistType, in:InTestlistType), UnionEvalType) ==>>
    { UnionEvalType = [] },
    eval_union_type(CompIterType, _),
    eval_union_type(ForExprlistType, _),
    eval_union_type(InTestlistType, _).
eval_single_type(todo_compifcompiter(ValueExprType, CompIterType), UnionEvalType) ==>>
    { UnionEvalType = [] },
    eval_union_type(ValueExprType, _),
    eval_union_type(CompIterType, _).
eval_single_type(todo_decorated(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [] },
    maplist_kyfact_symrej(eval_union_type, ItemsTypes, _).
eval_single_type(todo_decorator_dottedname(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [] },
    maplist_kyfact_symrej(eval_union_type, ItemsTypes, _).
eval_single_type(todo_decorators(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [] },
    maplist_kyfact_symrej(eval_union_type, ItemsTypes, _).
eval_single_type(todo_dictgen(ValueExprType, CompForType), UnionEvalType) ==>>
    { UnionEvalType = [] },
    eval_union_type(ValueExprType, _),
    eval_union_type(CompForType, _).
eval_single_type(todo_dictkeyvaluelist(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [] },
    maplist_kyfact_symrej(eval_union_type, ItemsTypes, _).
eval_single_type(dictset_make(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [dictset_of_type(Union)] },
    maplist_kyfact_symrej_union(eval_union_type, ItemsTypes, Union).
eval_single_type(dictset_of_type(Type), UnionEvalType) ==>>
    { UnionEvalType = [dictset_of_type(EvalType)] },
    eval_union_type(Type, EvalType).
eval_single_type(todo_dottedname(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [] },
    maplist_kyfact_symrej(eval_union_type, ItemsTypes, _).
eval_single_type(subscript(X1,X2,X3), UnionEvalType) ==>>
    { UnionEvalType = [subscript(E1,E2,E3)] },
    eval_union_type(X1, E1),
    eval_union_type(X2, E2),
    eval_union_type(X3, E3).
eval_single_type(todo_arg(_Name, Arg), UnionEvalType) ==>>
    { UnionEvalType = [] },
    % TODO: Name should match against the same name in function type
    %       (except for **kwargs).
    % TODO: should return something?
    eval_union_type(Arg, _).
eval_single_type(list_make(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [list_of_type(Union)] },
    maplist_kyfact_symrej_union(eval_union_type, ItemsTypes, Union).
eval_single_type(list_of_type(Type), UnionEvalType) ==>>
    { UnionEvalType = [list_of_type(EvalType)] },
    eval_union_type(Type, EvalType).
% Note: list_of_type_binds/1 should never appear in symtab because
%       it should only appear on l.h.s. of assignment.
eval_single_type(list_make_binds(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [list_of_type_binds(Union)] },
    maplist_kyfact_symrej_union(eval_union_type, ItemsTypes, Union).
eval_single_type(list_make_binds(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [list_of_type_binds(Union)] },
    maplist_kyfact_symrej_union(eval_union_type, ItemsTypes, Union).
eval_single_type(exprlist(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [list_of_type(Union)] },
    maplist_kyfact_symrej_union(eval_union_type, ItemsTypes, Union).
eval_single_type(exprlist_binds(ItemsTypes), UnionEvalType) ==>>
    { UnionEvalType = [list_of_type_binds(Union)] },
    maplist_kyfact_symrej_union(eval_union_type, ItemsTypes, Union).
eval_single_type(stmt(stmts), UnionEvalType) ==>> % TODO: how can stmt(stmts) get here? DO NOT SUBMIT
    { UnionEvalType = [] } .
eval_single_type(parse_error(Node), UnionEvalType) ==>>
    { UnionEvalType = [] },
    { Node = 'ParseError'{context: Context, msg: Msg, type: Type, value: Value, srcpath: SrcPath} }, % DO NOT SUBMIT - might not match
    eval_single_type_error_msg('Parse error', [],
                               '~w (type=~w) value=~q context:~w file:~q',
                               [Msg, Type, Value, Context, SrcPath]).
eval_single_type(decode_error(Node), UnionEvalType) ==>>
    { UnionEvalType = [] },
    { Node = 'DecodeError'{encoding:Encoding, start:Start, end:End, reason:Reason, srcpath: SrcPath} }, % DO NOT SUBMIT - might not match
    eval_single_type_error_msg('Decode error', [],
                               'Bad input (decoding ~w): ~w start=~w end=~w file:~q',
                               [Encoding, Reason, Start, End, SrcPath]).
eval_single_type(crash(Node), UnionEvalType) ==>>
    { UnionEvalType = [] },
    { Node = 'Crash'{repr: Repr, str: Str, srcpath: SrcPath} }, % DO NOT SUBMIT - might not match
    eval_single_type_error_msg('Crash wile processing file', [],
                               'Crash: ~w repr:~w file:~q',
                               [Str, Repr, SrcPath]).

:- det(eval_single_type_error_msg/7).
eval_single_type_error_msg(FmtMessage, ArgsMessage, FmtDetails, ArgsDetails) ==>>
    Meta/file_meta,
    { string_length(Meta.contents_bytes, AstnEnd) },
    { Astn = astn(0, AstnEnd, '-msg-') },
    kyanchor(0, AstnEnd, '-msg-', _AnchorSource),
    log_kyfact_msg(Astn, FmtMessage, ArgsMessage, FmtDetails, ArgsDetails).

:- det(eval_single_type_import/10).
% TODO: Do these ChildOfEdge facts do anything that isn't done elsewhere? DO NOT SUBMIT
eval_single_type_import(NameAstn, _ResolvedFqn, BindsOrRefEdge, _ChildofEdge, import_ref_type(_Name, ImportFqn, _Type)) ==>>
    % TODO: childof DO NOT SUBMIT
    kyanchor_node_kyedge_fqn(NameAstn, BindsOrRefEdge, ImportFqn).
eval_single_type_import(NameAstn, _ResolvedFqn, BindsOrRefEdge, ChildofEdge, class_type(ClassFqn, _)) ==>>
    kyedge_fqn_fqn(NameAstn, ChildofEdge, ClassFqn),
    kyanchor_node_kyedge_fqn(NameAstn, BindsOrRefEdge, ClassFqn).
eval_single_type_import(NameAstn, _ResolvedFqn, BindsOrRefEdge, ChildofEdge, module_type(Module)) ==>>
    { module_part(Module, ImportFqn) },
    kyedge_fqn_fqn(NameAstn, ChildofEdge, ImportFqn),
    kyanchor_node_kyedge_fqn(NameAstn, BindsOrRefEdge, ImportFqn).
eval_single_type_import(NameAstn, ResolvedFqn, BindsOrRefEdge, ChildofEdge, []) ==>>
    kyedge_fqn_fqn(NameAstn, ChildofEdge, ResolvedFqn), % TODO: verify DO NOT SUBMIT
    kyanchor_node_kyedge_fqn(NameAstn, BindsOrRefEdge, ResolvedFqn).

:- det(eval_atom_dot_single/8).
%! eval_atom_dot_single(+AttrAstn, +AtomSingleType:ordset, -EvalType:ordset)// is det.
% [kyfact,symrej,file_meta]
% Helper for single type-dot-attr.
% See also https://github.com/python/typeshed/issues/2726
% TODO: list, set, etc. (from builtins)
%          but need to handle MutableSequence(Sequence[_T], Generic[_T]), etc.
%          if their methods arent' @overload-ed in builtins.
%   -- for all else, use builtins.object as MRO
eval_atom_dot_single(AttrAstn, class_type(ClassName, Bases), EvalType) ==>>
    (   { setof(Mro, c3:mro(class_type(ClassName, Bases), Mro), Mros0) }
    ->  [ ]
    ;   { Mros0 = [[ClassName]] }
    ),
    { object_fqn(ObjectFqn) },
    { maplist(ensure_class_mro_object(ObjectFqn), Mros0, Mros) },
    maplist_kyfact_symrej_union(resolve_mro_dot(ClassName, AttrAstn), Mros, EvalType).
eval_atom_dot_single(AttrAstn,  module_type(module_alone(Module,_Path)), EvalType) ==>>
    { AttrAstn= astn(_Start,_End,Attr) },
    { join_fqn([Module, Attr], FqnAttr) },
    [ FqnAttr-EvalType-TypeSymtab ]:symrej,
    kyfact_attr(FqnAttr, AttrAstn, TypeSymtab).
eval_atom_dot_single(AttrAstn, module_type(module_and_token(Module,_Path,Token)), EvalType) ==>>
    % TODO: test case -- see i1.py (III().x)
    { AttrAstn= astn(_Start,_End,Attr) },
    { join_fqn([Module, Token, Attr], FqnAttr) },
    [ FqnAttr-EvalType-TypeSymtab ]:symrej,
    kyfact_attr(FqnAttr, AttrAstn, TypeSymtab).
eval_atom_dot_single(AttrAstn, import_ref_type(_Name, _Fqn, AtomSingleType), EvalType) ==>>
    eval_atom_dot_single(AttrAstn, AtomSingleType, EvalType).
eval_atom_dot_single(AttrAstn, function_type(FunctionName,Params,Return), EvalType) ==>>
    maplist_kyfact_symrej(eval_union_type, Params, _),
    eval_union_type(Return, _),
    { AttrAstn= astn(_Start,_End,Attr) },
    { join_fqn([FunctionName, Attr], FqnAttr) },
    [ FqnAttr-EvalType-TypeSymtab ]:symrej,
    kyfact_attr(FqnAttr, AttrAstn, TypeSymtab).
eval_atom_dot_single(AttrAstn, AtomSingleType, EvalType) ==>>
    (   { atom(AtomSingleType) }
    ->  { AttrAstn= astn(_Start,_End,Attr) },
        { join_fqn([AtomSingleType, Attr], FqnAttr) },
        [ FqnAttr-EvalType-TypeSymtab ]:symrej,
        % TODO: if AtomSingleType = function_type(Name,Params,Return)
        %          builtins_symtab_primitive(function, FunctionType)
        %          apply dot operator
        kyfact_attr(FqnAttr, AttrAstn, TypeSymtab)
    ;   { EvalType = [] }  % TODO - is this correct? DO NOT SUBMIT - note that
             % it's called in the context of maplist_kyfact_symrej_union(eval_atom_dot_single(AttrAstn), AtomEval, EvalType).
    ).

:- det(eval_atom_subscr_single/7).
%! eval_atom_subscr_single(+Expr, -EvalType)// is det.
% [kyfact,symrej,file_meta]
% Get the type of applying a subscript operator to a type.
eval_atom_subscr_single(list_of_type(Class), EvalType) ==>>
    { EvalType = Class }.
eval_atom_subscr_single(list_of_type_binds(Class), EvalType) ==>>
    { EvalType = Class }.
eval_atom_subscr_single(dictset_of_type(_Class), EvalType) ==>>
    { EvalType = [] }. % TODO: evaluate this
eval_atom_subscr_single(_, EvalType) ==>>
    { EvalType = [] }.

:- det(eval_atom_subscr_binds_single/7).
%! eval_atom_subscr_binds_single(+Expr, -EvalType)// is det.
% [kyfact,symrej,file_meta]
% eval_single_type, for binding context of subscr_op_binds
% This special-cases for a var_ref or '.' and doesn't evaluate it further
% (eval_single_type does a lookup).
eval_atom_subscr_binds_single(var_ref(Name), EvalType) ==>>
    { EvalType = [var_ref(Name)] }.
eval_atom_subscr_binds_single(dot_op(Atom,AttrAstn), DotEvals) ==>>
    eval_union_type(Atom, AtomEval),
    maplist_kyfact_symrej_union(subscr_resolve_dot_binds(AttrAstn), AtomEval, DotEvals).
eval_atom_subscr_binds_single(Expr, ExprEval) ==>>
    eval_single_type(Expr, ExprEval).

:- det(subscr_resolve_dot_binds/8).
%! subscr_resolve_dot_binds(+AttrAstn, +AtomType, -UnionEvalType) is det.
subscr_resolve_dot_binds(astn(Start,End,AttrName), class_type(ClassName,_Bases), UnionEvalType) ==>>
    { UnionEvalType = [var_ref(DotEval)] },
    { join_fqn([ClassName, AttrName], DotEval) },
    % This is within a subscr operator, so it's a ref, not binds:
    kyanchor_kyedge_fqn(Start, End, AttrName, '/kythe/edge/ref', DotEval).
subscr_resolve_dot_binds(_Astn, _AtomEval, UnionEvalType) ==>>
    { UnionEvalType = [] }.

:- det(ensure_class_mro_object/3).
%! ensure_class_mro_object(+ObjectFqn, +Mro0, -Mro) is det.
% If class 'object' (passed in as ObjectFqn) not in Mro0, then add it
% at the end. Mro is Mr0 'object' in it.
ensure_class_mro_object(ObjectFqn, Mro0, Mro) :-
    (   memberchk(ObjectFqn, Mro0)
    ->  Mro = Mro0
    ;   (   append(Mro0, [ObjectFqn], Mro) -> true ; fail )
    ).

%! resolve_mro_dot(+ClassName:atom, +AttrAstn, +Mro:list(atom), -EvalType:ordset(atom))// is det.
% [kyfact,symrej,file_meta]
% Using MRO, resolve Attr and add /kythe/edge/ref edge. If it couldn't
% be resolved, do best guess using ClassName.  EvalType is the
% resulting type. This never adds to symtab, so symtab lookup can be
% used to check if an attr exists for a class in the MRO.
resolve_mro_dot(ClassName, AttrAstn, Mro, EvalType) ==>>
    (   maybe_resolve_mro_dot(Mro, AttrAstn, EvalType)
    ->  [ ]
    ;   % Couldn't find it, so assume it's part of ClassName
        { AttrAstn= astn(_Start,_End,Attr) },
        { join_fqn([ClassName, Attr], FqnAttr) },
        { EvalType = [] },
        kyfact_attr(FqnAttr, AttrAstn, EvalType)
    ).

%! maybe_resolve_mro_dot(+Mro:list(atom), +AttrAstn, -EvalType:ordset(atom))// is semidet.
% [kyfact,symrej,file_meta]
% Using MRO, resolve Attr and add /kythe/edge/ref edge, setting
% EvalType as the symtab entry. Fail if Attr can't be resolved. We're
% guaranteed that dot-resolution won't put an entry into symtab, so
% symtab lookup can be used to check if an attr exists for a class in
% the MRO.
maybe_resolve_mro_dot([MroBaseName|Mros], AttrAstn, EvalType) -->>
    { AttrAstn = astn(_Start,_End,Attr) },
    { join_fqn([MroBaseName, Attr], FqnAttr) },
    (   symtab_lookup(FqnAttr, EvalType)
    ->  kyfact_attr(FqnAttr, AttrAstn, EvalType)
    ;   maybe_resolve_mro_dot(Mros, AttrAstn, EvalType)
    ).

:- det(eval_atom_call_single/8).
%! eval_atom_call_single(+Args, +AtomSingleType, -UnionEvalType:ordset)// is det.
% [kyfact,symrej,file_meta]
% Helper for eval_single_type.
% See also single_type_fqn/2, class_no_base/2, normalize_type2/2.
eval_atom_call_single(_Args, class_type(Fqn,Bases), UnionEvalType) ==>>
    % TODO: MRO for__init__ and output /kythe/edge/ref to it
    { UnionEvalType = [class_type(Fqn,Bases)] }.
eval_atom_call_single(Args, import_ref_type(_Name,_Fqn,Type), UnionEvalType) ==>>
    eval_atom_call_single(Args, Type, UnionEvalType).
eval_atom_call_single(_Args, function_type(_,Params,Return), ReturnType) ==>>
    maplist_kyfact_symrej(eval_union_type, Params, _),
    eval_union_type(Return, ReturnType).
% TODO: look for a __call__ method
eval_atom_call_single(_Args, _AtomSingleType, UnionEvalType) ==>>  % Don't know how to call anything else.
    { UnionEvalType = [] }.

:- det(resolve_unknown_fqn/7).
%! resolve_unknown_fqn(+FqnStack:list(atom), +NameAstn, -ResolvedFqn, -Type)// is det.
% [symrej,file_meta]
% Dynamic lookup of a name, given its "scope" (see
% NameBindsGlobalUnknown in ast_cooked.py)
resolve_unknown_fqn([], NameAstn, ResolvedFqn, Type) ==>>
    Meta/file_meta,
    { node_astn(NameAstn, _, _, Name) },
    { join_fqn([Meta.src_fqn, Name], ResolvedFqn) },
    [ ResolvedFqn-Type-_ ]: symrej. % Not found, so add it at module scope
resolve_unknown_fqn([Fqn|Fqns], NameAstn, ResolvedFqn, Type) ==>>
    { node_astn(NameAstn, _, _, Name) },
    { join_fqn([Fqn, Name], MaybeResolvedFqn) },
    (   symtab_lookup(MaybeResolvedFqn, Type)
    ->  { ResolvedFqn = MaybeResolvedFqn }
    ;   resolve_unknown_fqn(Fqns, NameAstn, ResolvedFqn, Type)
    ).

:- det(clean_class/3).
%! clean_class(+ClassName:atom, +Bases:list, -BasesCleaned:list) is det.
% Remove cycles and [] ("Any)" types from a class' list of base types.
clean_class(ClassName, Bases, BasesCleaned) =>
    maplist(maplist(normalize_base_class), Bases, Bases1),
    remove_class_cycles(Bases1, seen{}.put(ClassName, ''), Bases2),
    exclude(is_object_type, Bases2, BasesCleaned).

:- det(normalize_base_class/2).
%! normalize_base_class(+Type, -NormalizedType) is det.
normalize_base_class(import_ref_type(_Name,_Fqn,Type0), Type) =>
    normalize_base_class(Type0, Type).
normalize_base_class(class_type(Fqn, Bases0), Type) =>
    Type = class_type(Fqn, Bases),
    % TODO: the next step probably isn't needed because any included
    %       base classes should have already been cleaned:
    maplist(maplist(normalize_base_class), Bases0, Bases).
% ModuleType can occur if an invalid module path has been given.
normalize_base_class(module_type(ModuleType), Type) =>
    Type = module_type(ModuleType).

:- det(remove_class_cycles/3).
%! remove_class_cycles(+Bases:list(list), +Seen:dict, -BasesCleaned:list(list)) is det.
% Ensure that there are no cycles in the base classes of a class (see
% test cases for examples). Bases0 is the original list of bases;
% Bases gets the cycle-free bases. Seen is a dict (used as a set) of
% class names that have been seen so far; it should have an initial
% value of the class name (the dict values are ignored).  The
% resulting BasesCleaned may have some empty types, which equate to
% "Any"; the assumption is that the caller will remove them.
% (Hint for understanding this code -- each Base is a union (list) of
% types.)
remove_class_cycles([], _Seen, BasesCleaned) => BasesCleaned = [].
remove_class_cycles([Base|Bases], Seen, BasesCleaned) =>
    BasesCleaned = [Base2|Bases2],
    remove_class_cycles_one(Base, Base2, Seen, Seen2),
    remove_class_cycles(Bases, Seen2, Bases2).

:- det(remove_class_cycles_one/4).
%! remove_class_cycles_one(+Types:list, -TypesOut:list, +Seen:dict, -SeenOut:dict) is det.
% Remove cycles for a single base.
% Seen is a dict (set) of already seen class names.
remove_class_cycles_one([], TypesOut, Seen, SeenOut) => TypesOut = [], SeenOut = Seen.
remove_class_cycles_one([Type|Types], TypesOut, Seen, SeenOut),
        Type = class_type(ClassName, _),
        key_in_dict(ClassName, Seen) =>
    remove_class_cycles_one(Types, TypesOut, Seen, SeenOut).
remove_class_cycles_one([Type|Types], TypesOut, Seen, SeenOut) =>
    TypesOut = [Type|Types2],
    (   Type = class_type(ClassName)
    ->  put_dict(ClassName, Seen, '', Seen2)
    ;   Seen2 = Seen
    ),
    remove_class_cycles_one(Types, Types2, Seen2, SeenOut).

key_in_dict(Key, Dict) :- get_dict(Key, Dict, _).

%%%%%%              %%%%%%%
%%%%%% Accumulators %%%%%%%
%%%%%%              %%%%%%%

:- det(add_rej_to_symtab/3).
%! add_rej_to_symtab(+FqnRejType:pair, +Symtab0, -Symtab) is det.
% For Fqn-RejType pairs in FqnRejTypes, add to symtab.
add_rej_to_symtab(Fqn-RejType, Symtab0, Symtab) =>
    symtab_lookup(Fqn, Symtab0, FqnType),
    type_union(FqnType, RejType, UnionType),
    symtab_insert(Fqn, Symtab0, UnionType, Symtab).

:- det(symrej_accum/3).
%! symrej_accum(+FqnType:triple, +Symtab0Rej0Mod0, -SymtabRejMod) is det.
% The accumulator for 'symrej'.
% FqnType = Key-Type-TypeSymtab.
% Tries to unify Key-Type with what's already in symtab; if that
% fails because it's not in the symtab, adds it to symtab; otherwise
% unions it with what's in symtab and adds it to Rej. TypeSymtab is
% unified with the result.
% See table of actions in the top-level documentation.
% (This means that the first time a symbol is added to the symtab, it
% doesn't go into Rej; but if a subsequent lookup gives additional
% type information, then it goes into Rej. This is a small
% optimization that can sometimes avoid one pass over the source.)
% Symtab0Rej0Mod0 and SymtabRejMod are sym_rej/2 functors.
% If Type is uninstantiated it gets set to []
% TODO: can we eliminate the "(Type=[]->true;true)" ?
%       One way would be to do an initial pass that
%       enters all the identifiers into symtab (with type=[]).
symrej_accum(Fqn-Type-TypeSymtab, sym_rej(Symtab0,Rej0), SymtabRejMod) =>
    SymtabRejMod = sym_rej(Symtab,Rej),
    (   symtab_lookup(Fqn, Symtab0, TypeSymtab)
    ->  symrej_accum_found(Fqn, Type, TypeSymtab, Symtab0, Symtab, Rej0, Rej)
    ;   % ensure Type is instantiated (defaults to []), if this is a lookup
        % see comment in eval_single_type//1
        (   Type = []       % Either a lookup that failed or "any" type
        ->  Rej = Rej0
        ;   Rej = [Fqn-Type|Rej0] % new information is a "rej"  DO NOT SUBMIT - add explanation for module_type
        ),
        TypeSymtab = Type,
        symtab_insert(Fqn, Symtab0, Type, Symtab)
    ).

%! symtab_lookup(+Fqn, ?Type)// is semidet.
% [symrej]
% Succeeds if Fqn is in Symtab with Type.
% TODO: use this to make symrej_accum/3 more logical (see comments
%       there and eval_single_type//1).
symtab_lookup(Fqn, Type) ==>>
    sym_rej(Symtab,_)/symrej,
    { symtab_lookup(Fqn, Symtab, Type) }.

%! symtab_scope_pairs(+FqnStack, -SymtabPairsScope) is det.
symtab_scope_pairs(FqnStack, SymtabPairsScope) ==>>
    sym_rej(Symtab,_)/symrej,
    { symtab_scope_pairs(FqnStack, Symtab, SymtabPairsScope) }.

:- det(symrej_accum_found/7).
%! symrej_accum_found(+Fqn, +Type, +TypeSymtab, +Symtab0, -Symtab, +Rej0, -Rej) is det.
% Helper for symrej_accum/3 for when Fqn is in Symtab with value
% TypeSymtab (Type is the new type).
% Symtab gets updated type information for Fqn, and Rej is added to
% if there was any change to the entry in Symtab.
symrej_accum_found(Fqn, Type, TypeSymtab, Symtab0, Symtab, Rej0, Rej) :-
    (   Type = TypeSymtab % also handles Type is uninstantiated (i.e., a lookup)
    ->  Symtab = Symtab0,
        Rej = Rej0
    ;   type_union(TypeSymtab, Type, TypeComb),
        (   TypeComb = TypeSymtab
        ->  Symtab = Symtab0,
            Rej = Rej0
        ;   symtab_insert(Fqn, Symtab0, TypeComb, Symtab),
            Rej = [Fqn-Type|Rej0]
        )
    ).

:- det(possible_classes_from_attr/5).
%! possible_classes_from_attr(+AttrName:atom, -ClassFqn:atom)// is det.
% [symrej,file_meta]
% Compute a set of possible classes, given an attribute. This looks
% at all the classes in the symtab and finds those that have AttrName.
possible_classes_from_attr(AttrName, Classes) ==>>
    sym_rej(Symtab,_)/symrej,
    { classes_from_attr_(Symtab, AttrName, Classes0) },
    { combine_types(Classes0, Classes) }.

:- det(classes_from_attr_/3).
%! classes_from_attr(+Symtab, +AttrName:atom, -Classes) is det.
% Given an AttrName, find symbol table entries for classes that
% define/use it.
% TODO: classes_from_attr/3 uses 48% of processing (according to
%       profile/1), almost all in rb_conv_pairs_4 (called from
%       conv_symtab_pairs).  The problem seesm to be that we do a scan
%       of the entire symtab; so probably should have an inverted list
%       for class attributes.  - BUT: this probably only applies to
%       sources that have lots of unresolved attributes, so better to
%       first concentrate on resolving as many attrs as possible.
% TODO: https://github.com/kamahen/pykythe/issues/38
classes_from_attr_(_Symtab, AttrName, Classes),
        common_attr(AttrName) =>
    Classes = [].
classes_from_attr_(Symtab, AttrName, Classes) =>
    atomic_list_concat(['.', AttrName], DotAttrName),
    conv_symtab_pairs(attr_candidate(Symtab, DotAttrName), Symtab, Candidates),
    pairs_values(Candidates, Classes).

attr_candidate(Symtab, DotAttrName, Fqn-_, ClassFqnClass) =>
    ClassFqnClass = ClassFqn-Class,
    remove_suffix(Fqn, DotAttrName, ClassFqn),
    % There are some corner cases that the following doesn't handle,
    % such as a class defined within a function but they're rare:
    \+ sub_atom(ClassFqn, _, _, _, '<'), % doesn't contain '<local>', '<comp_for>', etc.
    symtab_lookup(ClassFqn, Symtab, Class).

:- det(log_possible_classes_from_attr/9).
%! log_possible_classes_from_attr(+BindsOrRef:atom, +AttrAstn, +Classes, +AtomType)// is nondet.
% [kyfact,symrej,file_meta]
log_possible_classes_from_attr(BindsOrRef, astn(Start,End,AttrName), Classes, AtomType) ==>>
    Meta/file_meta,
    { maplist(class_no_base, Classes, ClassesNoBase) },
    { sort(ClassesNoBase, ClassesNoBaseSorted) },
    { length(ClassesNoBaseSorted, Len) },
    (   { Len = 0 }
    ->  { Msg0 = 'WARNING' },
        { ClassesShow = [] }
    ;   { Len < 15 }
    ->  { Msg0 = 'INFO' },
        { ClassesShow = ClassesNoBaseSorted }
    ;   { Msg0 = 'WARNING' },
        { length(ClassesShow, 15) },
        { append(ClassesShow2, _, ClassesNoBaseSorted) }, % Only show first few
        { append(ClassesShow2, ['...'], ClassesShow) },
        ! % remove append/3 choicepoint
    ),
    log_kyfact_msg(astn(Start,End,AttrName),
                   '~w: guessed attribute classes/modules for \'~w\'', [Msg0, AttrName],
                   '~w: attr \'~w\' (~w) ~w possible modules/classes in ~q @~w-~w: ~q (atomtype: ~q)', [Msg0, AttrName, BindsOrRef, Len, Meta.path, Start, End, ClassesShow, AtomType]).

:- det(log_kyfact_msg/8).
%! log_kyfact_msg(+Astn, +FmtMessage, +ArgsMessage, +FmtDetails, +ArgsDetails)// is det.
% [kyfact,file_meta]
% Add a message to the kyfact accumulator. This is to ensure that
% messages that might appear on one pass but not on a later pass
% (e.g., can't resolve a name).
log_kyfact_msg(Astn, FmtMessage, ArgsMessage, FmtDetails, ArgsDetails) ==>>
    { format(string(MessageMsg), FmtMessage, ArgsMessage) },
    { format(string(DetailsMsg), FmtDetails, ArgsDetails) },
    [ msg{message: MessageMsg, details:DetailsMsg, astn: Astn} ]:kyfact,
    { Astn = astn(Start, End, Token) },
    { anchor_signature_str(Start, End, Token, AnchorSignature) },
    signature_source(AnchorSignature, Source),
    diagnostic_source(AnchorSignature, DiagnosticSource),
    kyfact(DiagnosticSource, '/kythe/node/kind', 'diagnostic'),
    kyfact(DiagnosticSource, '/kythe/message', MessageMsg),
    kyfact(DiagnosticSource, '/kythe/details', DetailsMsg),
    kyedge(Source, '/kythe/edge/tagged', DiagnosticSource).

%! common_attr(?AttrName) is semidet.
% Attributes that occur so commonly and with so many possibilities
% that they're not useful for possible_class_from_attr.
common_attr('__init__'). % Occurs when people use a class's __init__ instead of super()
% Other attributes that are common in (e.g., llvm, importlab) but not others:
% 'format'
% 'id'
% 'object'
% 'open'
% 'set'
% 'type'

%%%%%%           %%%%%%%
%%%%%% Utilities %%%%%%%
%%%%%%           %%%%%%%

%% The predicates for handling types are a thin wrapper around
%% "ordsets". It is anticipated that some normalization will be
%% needed, but currently there isn't any.

:- det(type_union/3).
%! type_union(+Set1, +Set2, -Set) is det.
type_union(Type1, Type2, UnionType) :-
    ord_union(Type1, Type2, UnionType0),
    normalize_type(UnionType0, UnionType).

:- det(type_add_element/3).
%! type_add_element(+Set1, +Element, ?Set2) is det.
type_add_element(Type0, Element, Type) :-
    ord_add_element(Type0, Element, Type1),
    normalize_type(Type1, Type).

%! list_to_union_type(+List, -OrdSet) is det.
list_to_union_type(List, Type) :-
    list_to_ord_set(List, Type0),
    normalize_type(Type0, Type).

:- det(maplist_kyfact_symrej_union/8).
%! maplist_kyfact_symrej_union(:Pred, L:list, EvalType:ordset)// is det.
% [kyfact,symrej,file_meta]
% maplist/3 for EDCG [kyfact,symrej,file_meta] + combine_types
maplist_kyfact_symrej_union(Pred, L, EvalType) ==>>
    maplist_kyfact_symrej(Pred, L, EvalType0),
    { combine_types(EvalType0, EvalType) }.

:- det(combine_types/2).
%! combine_types(+ListOfOrdSets, -Set) is det.
combine_types(ListOfTypes, Type) =>
    ord_union(ListOfTypes, Type0),
    normalize_type(Type0, Type).

:- det(normalize_type/2).
%! normalize_type(+Type, -NormalizedType) is det.
normalize_type(Type0, Type) :-
    exclude(is_object_type, Type0, Type1),
    normalize_type2(Type1, Type2),
    list_to_ord_set(Type2, Type). % Probably not needed, but just in case

:- det(normalize_type2/2).
%! normalize_type2(+Type, -NormalizedType) is det.
% See also class_no_base/2 etc.
normalize_type2(Type0, Type) :-
    select(class_type(C, []), Type0, Type1),
    (  memberchk(class_type(C, _), Type1)
    ;  memberchk(import_ref_type(_, _, class_type(C, _)), Type1)
    ),
    !,
    normalize_type2(Type1, Type).
normalize_type2(Type0, Type) :-
    select(function_type(F, _, []), Type0, Type1),
    (  memberchk(function_type(F, _, _), Type1)
    ;  memberchk(import_ref_type(_, _, function_type(F, _, _)), Type1)
    ),
    !,
    normalize_type2(Type1, Type).
normalize_type2(Type0, Type) :-
    select(import_ref_type(_Name, _Fqn, T), Type0, Type1),
    memberchk(import_ref_type(_, _, T), Type1),
    !,
    normalize_type2(Type1, Type).
% DO NOT SUBMIT -- module -> class + simplify base classes
normalize_type2(Type0, Type) :- Type = Type0. % TODO: this probably is unsufficient.

%! is_object_type(+Type) is semidet.
is_object_type([]) :- !.
is_object_type(Type) :-
    builtins_symtab_primitive(object, Type), !.
is_object_type(Type) :-
    builtins_symtab_primitive(object, [Type]), !.
is_object_type(import_ref_type(_Name, _Fqn, Type)) :- !,
    is_object_type(Type).

% TODO: is this being used, or is some additional setup needed?
prolog:message(goal_failed(Goal)) -->
    [ 'Goal failed: ~p'-[Goal] ].

goal_failed(Goal) :-
    throw(error(goal_failed(Goal), _)),
    fail.

user:portray(Term) :-
    % in the following, format/2 is used because
    % print_message(warning, E) gives an infinite recursion.
    E = error(ErrorTerm, _Context), % avoid trapping abort, timeout, etc.
    % _Context = context(pykythe:pykythe_portray/1,_)
    catch(pykythe_portray(Term),
          E,
          format('portrayEXCEPTION/~q:~q', [ErrorTerm, Term])).

%! pykythe_portray is semidet.
%  TODO: change all to use pykythe_portray_unify (see 1st clause).
pykythe_portray(Astn) :-
    node_astn(Astn0, Start, End, Value),
    pykythe_portray_unify(Astn0, Astn),
    integer(Start), integer(End),
    !,
    format("'ASTN'(~w:~w, ~q)", [Start, End, Value]).
pykythe_portray('NameBareNode'{name:Astn}) :-
    format("'NameBareNode'{name:~p}", [Astn]).
pykythe_portray(module_and_token(Path, Token)) :-
    format("module_and_token(~p, ~p)", [Path, Token]).
pykythe_portray(str(S)) :- !,
    format('str(~q)', [S]).
pykythe_portray(bool(B)) :- !,
    format('bool(~q)', [B]).
pykythe_portray('StringNode'{astns: [Astn]}) :- !, % doesn't handle "foo" "bar"
    format("'StringNode'{astns:[~p]}", [Astn]).
pykythe_portray('StringBytesNode'{astns: [Astn]}) :- !, % doesn't handle "foo" "bar"
    format("'StringBytesNode'{astns:[~p]}", [Astn]).
pykythe_portray('NumberComplexNode'{astn: Astn}) :-
    format("'NumberComplexNode'{astn:~p}", [Astn]).
pykythe_portray('NumberFloatNode'{astn: Astn}) :-
    format("'NumberFloatNode'{astn:~p}", [Astn]).
pykythe_portray('NumberIntNode'{astn: Astn}) :-
    format("'NumberIntNode'{astn:~p}", [Astn]).
pykythe_portray(op([Astn])) :-
    node_astn(Astn, _, _, _), !,
    format('op([~p])', [Astn]).
pykythe_portray(var_ref(X)) :- !,
    format('var_ref(~p)', [X]).
pykythe_portray(var_binds(X)) :- !,
    format('var_binds(~p)', [X]).
pykythe_portray(var_binds_lookup(X)) :- !,
    format('var_binds_lookup(~p)', [X]).
pykythe_portray(var_ref_lookup(X)) :- !,
    format('var_ref_lookup(~p)', [X]).
pykythe_portray(function_type(F,P,R)) :- !,
    format('function_type(~p, ~p, ~p)', [F, P, R]).
pykythe_portray(class_type(F, R)) :- !,
    format('class_type(~p, ~p)', [F, R]).
pykythe_portray(import_ref_type(N,F,T)) :- !,
    format('import_ref_type(~p, ~p, ~p)', [N, F, T]).
pykythe_portray(union(U)) :- !,
    format('union(~p)', [U]).
pykythe_portray(astn(Start, End, String)) :- !,
    format('astn(~p,~p, ~p)', [Start, End, String]).
pykythe_portray('*list*'(List)) :- !, % To make print_term output more compact
    format('~p', [List]).
pykythe_portray(Meta) :-
    is_dict(Meta),
    meta{kythe_corpus: KytheCorpus,
         kythe_root: KytheRoot,
         path: Path,
         src_fqn: SrcFqn} :< Meta,
    !,
    dict_pairs(Meta, _, MetaPairs),
    pairs_keys(MetaPairs, MetaKeys),
    format('meta{~q, ~q, ~q, ~q, ...: ~q}', [KytheCorpus, KytheRoot, Path, SrcFqn, MetaKeys]).
pykythe_portray('$VAR'('_')) :- !, % work around a bug in print_term
    format('_', []).          % (numbervars(true) should handle this)
pykythe_portray('$VAR'(N)) :- !,
    Chr is N + 65,
    format('~c', [Chr]).
pykythe_portray(Assoc) :-
    is_assoc(Assoc), !,
    aggregate_all(count, gen_assoc(_, Assoc, _), Length),
    min_assoc(Assoc, MinKey, MinValue),
    max_assoc(Assoc, MaxKey, MaxValue),
    format('<assoc:~w, ~p: ~p ... ~p: ~p>', [Length, MinKey, MinValue, MaxKey, MaxValue]).
pykythe_portray(Dict) :-
    is_dict(Dict, Tag),
    !,
    dict_pairs(Dict, Tag, Entries),
    length(Entries, NumEntries),
    (   NumEntries < 30
    ->  format('~q{', [Tag]),
        pykythe_portray_dict_entries(Entries),
        format('}', [])
    ;   format('~q{<~w items>...}', [Tag, NumEntries])
    ).
pykythe_portray(Symtab) :-
    is_symtab(Symtab),
    !,
    symtab_size(Symtab, NumEntries),
    (   NumEntries < 30
    ->  symtab_pairs(Symtab, Entries),
        format('symtab{', []),
        pykythe_portray_dict_entries(Entries),
        format('}', [])
    ;   format('symtab{<~w items>...}', [NumEntries])
    ).

pykythe_portray_dict_entries(Entries) :-
    pykythe_portray_dict_entries(Entries, '').

pykythe_portray_dict_entries([], _Sep) => true.
pykythe_portray_dict_entries([K-V|KVs], Sep) =>
    format('~w~q:~q', [Sep, K, V]),
    pykythe_portray_dict_entries(KVs, ', ').

%! pykythe_portray_unify(?Generic, ?Term).
% A "safe" version of unify, for pykythe_portray/1.
pykythe_portray_unify(Generic, Term) :-
    subsumes_term(Generic, Term),
    Generic = Term.

% Variants on maplist, foldl (and combinations of them), bagof for EDCGs

:- det(maplist_kyfact/5).
%! maplist_kyfact(:Pred, +L:list)// is det.
% [kyfact,file_meta]
% maplist/2 for EDCG [kyfact,file_meta]
maplist_kyfact(Pred, L) ==>> maplist_kyfact_(L, Pred).

:- det(maplist_kyfact_/5).
maplist_kyfact_([], _Pred) ==>> [ ].
maplist_kyfact_([X|Xs], Pred) ==>>
    call(Pred, X):[kyfact,file_meta],
    maplist_kyfact_(Xs, Pred).

:- det(maplist_kyfact/6).
%! maplist_kyfact(:Pred, +L0:list, -L:list)// is det.
% [kyfact,file_meta]
% maplist/3 for EDCG [kyfact,file_meta]
maplist_kyfact(Pred, L0, L) ==>> maplist_kyfact_(L0, Pred, L).

:- det(maplist_kyfact_/6).
maplist_kyfact_([], _Pred, Out) ==>>
    { Out = [] }.
maplist_kyfact_([X|Xs], Pred, Out) ==>>
    { Out = [Y|Ys] },
    call(Pred, X, Y):[kyfact,file_meta],
    maplist_kyfact_(Xs, Pred, Ys).

:- det(maplist_kyfact_symrej/7).
%! maplist_kyfact_symrej(:Pred, +L:list)// is det.
% [kyfact,symrej,file_meta]
% maplist/2 for EDCG [kyfact,symrej,file_meta]
maplist_kyfact_symrej(Pred, L) ==>> maplist_kyfact_symrej_(L, Pred).

:- det(maplist_kyfact_symrej_/7).
maplist_kyfact_symrej_([], _Pred) ==>> [ ].
maplist_kyfact_symrej_([X|Xs], Pred) ==>>
    call(Pred, X):[kyfact,symrej,file_meta],
    maplist_kyfact_symrej_(Xs, Pred).

:- det(maplist_kyfact_symrej/8).
%! maplist_kyfact_symrej(:Pred, +L0:list, -L:list)// is det.
% [kyfact,symrej,file_meta]
% maplist/3 for EDCG [kyfact,symrej,file_meta]
maplist_kyfact_symrej(Pred, L0, L) ==>> maplist_kyfact_symrej_(L0, Pred, L).

:- det(maplist_kyfact_symrej_/8).
maplist_kyfact_symrej_([], _Pred, Out) ==>>
    { Out = [] }.
maplist_kyfact_symrej_([X|Xs], Pred, Out) ==>>
    { Out = [Y|Ys] },
    call(Pred, X, Y):[kyfact,symrej,file_meta],
    maplist_kyfact_symrej_(Xs, Pred, Ys).

:- det(maplist_kyfact_expr/7).
%! maplist_kyfact_expr(:Pred, +L0:list)// is det.
% [kyfact,expr,file_meta]
% maplist/2 for EDCG [kyfact,expr,file_meta]
maplist_kyfact_expr(Pred, L) ==>> maplist_kyfact_expr_(L, Pred).

:- det(maplist_kyfact_expr_/7).
maplist_kyfact_expr_([], _Pred) ==>> [ ].
maplist_kyfact_expr_([X|Xs], Pred) ==>>
    call(Pred, X):[kyfact,expr,file_meta],
    maplist_kyfact_expr_(Xs, Pred).

:- det(maplist_kyfact_expr/8).
%! maplist_kyfact_expr(:Pred, +L0:list, -L:list)// is det.
% [kyfact,expr,file_meta]
% maplist/3 for EDCG [kyfact,expr,file_meta]
maplist_kyfact_expr(Pred, L0, L) ==>> maplist_kyfact_expr_(L0, Pred, L).

:- det(maplist_kyfact_expr_/8).
maplist_kyfact_expr_([], _Pred, Out) ==>>
    { Out = [] }.
maplist_kyfact_expr_([X|Xs], Pred, Out) ==>>
    { Out = [Y|Ys] },
    call(Pred, X, Y):[kyfact,expr,file_meta],
    maplist_kyfact_expr_(Xs, Pred, Ys).

trace_file(this_will_never_match).
% trace_file('/home/peter/src/typeshed/stdlib/collections/__init__.pyi'). % TODO: delete
% TODO: For debugging t4.pl node.children -- neeeds to understand _NL = Union[Node, Leaf]; cildren: List[_NL]
% trace_file('/home/peter/src/typeshed/stdlib/lib2to3/pytree.pyi'). % TODO: delete
% trace_file('/tmp/pykythe_test/SUBST/home/peter/src/pykythe/test_data/a10.py'). % TODO: delete

:- det(log_if_file/3).
log_if_file(Fmt, Args) ==>>
    Meta/file_meta,
    { log_if(trace_file(Meta.path), Fmt, Args) }.

:- meta_predicate do_if_file(0, +).

:- det(do_if_file/2).
%! do_if_file(:Goal) is det.
% Do the Goal if trace_file/1 matches Meta.path. (for debugging)
do_if_file(Goal) ==>>
    Meta/file_meta,
    { do_if(trace_file(Meta.path), Goal) }.

:- det(symtab_if_file/4).
%! symtab_if_file(+Msg:string)// is det.
% Dump the symtab if trace_file/1 matches Meta.path. (for debugging)
symtab_if_file(Msg) ==>>    % DO NOT SUBMIT - replace this with something that uses pykythe_symtab predicates.
    Meta/file_meta,
    sym_rej(Symtab,_)/symrej,
    (   { trace_file(Meta.path) }
    ->  { append_fqn_dot(Meta.src_fqn, SrcFqnDot) },
        { dict_pairs(Symtab, SymtabTag, SymtabPairs) },
        { log_if(true, 'SYMTAB SrcFqnDot: ~q', [SrcFqnDot]) },
        { convlist(starts_with_fqn_type(SrcFqnDot), SymtabPairs, SymtabPairs2) },
        { dict_pairs(Symtab2, SymtabTag, SymtabPairs2) },
        { log_if(true, '~w: ~q', [Msg, Symtab2]) }
    ;   [ ]
    ).

%! starts_with_fqn(+Prefix:atom, +Fqn_Type:pair(atom), -Fqn2_Type2:pair(atom)) is semidet.
% If Fqn has Prefix as a prefix, and the result isn't in the builtins,
% return the de-prefixed FQN with its type.
starts_with_fqn_type(Prefix, Fqn-Type, Fqn2Type) =>
    Fqn2Type = Fqn2-Type,
    (   remove_prefix(Fqn, Prefix, Fqn2a)
    ->  join_fqn(['<>', Fqn2a], Fqn2)
    % For debugging, the following can be used to show additional symtab entries:
    % ;  remove_prefix(Fqn, '.home.peter.src.typeshed.stdlib.lib2to3.', Fqn2a)
    %    join_fqn(['<lib2to3>', Fqn2a], Fqn2)
    ),
    builtins_pairs(BuiltinsPairs), % TODO: this is inefficient.
    \+ memberchk(Fqn2-_, BuiltinsPairs).

:- det(stats/1).
stats(Stats) :-
    maplist(statistic_kv, [atoms,cputime,globalused,localused,trail,stack], Stats).

:- det(statistic_kv/2).
statistic_kv(Key, KeyValue) =>
    KeyValue = Key:Value,
    statistics(Key, Value).

end_of_file.
